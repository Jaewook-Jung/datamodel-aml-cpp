// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "CAEX_Classmodel_V2.15.hxx"

// ChangeMode
// 

ChangeMode::
ChangeMode (value v)
: ::xml_schema::string (_xsd_ChangeMode_literals_[v])
{
}

ChangeMode::
ChangeMode (const char* v)
: ::xml_schema::string (v)
{
}

ChangeMode::
ChangeMode (const ::std::string& v)
: ::xml_schema::string (v)
{
}

ChangeMode::
ChangeMode (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

ChangeMode::
ChangeMode (const ChangeMode& v,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (v, f, c)
{
}

ChangeMode& ChangeMode::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_ChangeMode_literals_[v]);

  return *this;
}


// CAEXBasicObject
// 

const CAEXBasicObject::Description_optional& CAEXBasicObject::
Description () const
{
  return this->Description_;
}

CAEXBasicObject::Description_optional& CAEXBasicObject::
Description ()
{
  return this->Description_;
}

void CAEXBasicObject::
Description (const Description_type& x)
{
  this->Description_.set (x);
}

void CAEXBasicObject::
Description (const Description_optional& x)
{
  this->Description_ = x;
}

void CAEXBasicObject::
Description (::std::auto_ptr< Description_type > x)
{
  this->Description_.set (x);
}

const CAEXBasicObject::Version_optional& CAEXBasicObject::
Version () const
{
  return this->Version_;
}

CAEXBasicObject::Version_optional& CAEXBasicObject::
Version ()
{
  return this->Version_;
}

void CAEXBasicObject::
Version (const Version_type& x)
{
  this->Version_.set (x);
}

void CAEXBasicObject::
Version (const Version_optional& x)
{
  this->Version_ = x;
}

void CAEXBasicObject::
Version (::std::auto_ptr< Version_type > x)
{
  this->Version_.set (x);
}

const CAEXBasicObject::Revision_sequence& CAEXBasicObject::
Revision () const
{
  return this->Revision_;
}

CAEXBasicObject::Revision_sequence& CAEXBasicObject::
Revision ()
{
  return this->Revision_;
}

void CAEXBasicObject::
Revision (const Revision_sequence& s)
{
  this->Revision_ = s;
}

const CAEXBasicObject::Copyright_optional& CAEXBasicObject::
Copyright () const
{
  return this->Copyright_;
}

CAEXBasicObject::Copyright_optional& CAEXBasicObject::
Copyright ()
{
  return this->Copyright_;
}

void CAEXBasicObject::
Copyright (const Copyright_type& x)
{
  this->Copyright_.set (x);
}

void CAEXBasicObject::
Copyright (const Copyright_optional& x)
{
  this->Copyright_ = x;
}

void CAEXBasicObject::
Copyright (::std::auto_ptr< Copyright_type > x)
{
  this->Copyright_.set (x);
}

const CAEXBasicObject::AdditionalInformation_sequence& CAEXBasicObject::
AdditionalInformation () const
{
  return this->AdditionalInformation_;
}

CAEXBasicObject::AdditionalInformation_sequence& CAEXBasicObject::
AdditionalInformation ()
{
  return this->AdditionalInformation_;
}

void CAEXBasicObject::
AdditionalInformation (const AdditionalInformation_sequence& s)
{
  this->AdditionalInformation_ = s;
}

const CAEXBasicObject::ChangeMode_type& CAEXBasicObject::
ChangeMode () const
{
  return this->ChangeMode_.get ();
}

CAEXBasicObject::ChangeMode_type& CAEXBasicObject::
ChangeMode ()
{
  return this->ChangeMode_.get ();
}

void CAEXBasicObject::
ChangeMode (const ChangeMode_type& x)
{
  this->ChangeMode_.set (x);
}

void CAEXBasicObject::
ChangeMode (::std::auto_ptr< ChangeMode_type > x)
{
  this->ChangeMode_.set (x);
}

const CAEXBasicObject::ChangeMode_type& CAEXBasicObject::
ChangeMode_default_value ()
{
  return ChangeMode_default_value_;
}


// CAEXObject
// 

const CAEXObject::ID_optional& CAEXObject::
ID () const
{
  return this->ID_;
}

CAEXObject::ID_optional& CAEXObject::
ID ()
{
  return this->ID_;
}

void CAEXObject::
ID (const ID_type& x)
{
  this->ID_.set (x);
}

void CAEXObject::
ID (const ID_optional& x)
{
  this->ID_ = x;
}

void CAEXObject::
ID (::std::auto_ptr< ID_type > x)
{
  this->ID_.set (x);
}

const CAEXObject::Name_type& CAEXObject::
Name () const
{
  return this->Name_.get ();
}

CAEXObject::Name_type& CAEXObject::
Name ()
{
  return this->Name_.get ();
}

void CAEXObject::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void CAEXObject::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// InterfaceClassType
// 

const InterfaceClassType::Attribute_sequence& InterfaceClassType::
Attribute () const
{
  return this->Attribute_;
}

InterfaceClassType::Attribute_sequence& InterfaceClassType::
Attribute ()
{
  return this->Attribute_;
}

void InterfaceClassType::
Attribute (const Attribute_sequence& s)
{
  this->Attribute_ = s;
}

const InterfaceClassType::RefBaseClassPath_optional& InterfaceClassType::
RefBaseClassPath () const
{
  return this->RefBaseClassPath_;
}

InterfaceClassType::RefBaseClassPath_optional& InterfaceClassType::
RefBaseClassPath ()
{
  return this->RefBaseClassPath_;
}

void InterfaceClassType::
RefBaseClassPath (const RefBaseClassPath_type& x)
{
  this->RefBaseClassPath_.set (x);
}

void InterfaceClassType::
RefBaseClassPath (const RefBaseClassPath_optional& x)
{
  this->RefBaseClassPath_ = x;
}

void InterfaceClassType::
RefBaseClassPath (::std::auto_ptr< RefBaseClassPath_type > x)
{
  this->RefBaseClassPath_.set (x);
}


// InterfaceFamilyType
// 

const InterfaceFamilyType::InterfaceClass_sequence& InterfaceFamilyType::
InterfaceClass () const
{
  return this->InterfaceClass_;
}

InterfaceFamilyType::InterfaceClass_sequence& InterfaceFamilyType::
InterfaceClass ()
{
  return this->InterfaceClass_;
}

void InterfaceFamilyType::
InterfaceClass (const InterfaceClass_sequence& s)
{
  this->InterfaceClass_ = s;
}


// RoleClassType
// 

const RoleClassType::Attribute_sequence& RoleClassType::
Attribute () const
{
  return this->Attribute_;
}

RoleClassType::Attribute_sequence& RoleClassType::
Attribute ()
{
  return this->Attribute_;
}

void RoleClassType::
Attribute (const Attribute_sequence& s)
{
  this->Attribute_ = s;
}

const RoleClassType::ExternalInterface_sequence& RoleClassType::
ExternalInterface () const
{
  return this->ExternalInterface_;
}

RoleClassType::ExternalInterface_sequence& RoleClassType::
ExternalInterface ()
{
  return this->ExternalInterface_;
}

void RoleClassType::
ExternalInterface (const ExternalInterface_sequence& s)
{
  this->ExternalInterface_ = s;
}

const RoleClassType::RefBaseClassPath_optional& RoleClassType::
RefBaseClassPath () const
{
  return this->RefBaseClassPath_;
}

RoleClassType::RefBaseClassPath_optional& RoleClassType::
RefBaseClassPath ()
{
  return this->RefBaseClassPath_;
}

void RoleClassType::
RefBaseClassPath (const RefBaseClassPath_type& x)
{
  this->RefBaseClassPath_.set (x);
}

void RoleClassType::
RefBaseClassPath (const RefBaseClassPath_optional& x)
{
  this->RefBaseClassPath_ = x;
}

void RoleClassType::
RefBaseClassPath (::std::auto_ptr< RefBaseClassPath_type > x)
{
  this->RefBaseClassPath_.set (x);
}


// RoleFamilyType
// 

const RoleFamilyType::RoleClass_sequence& RoleFamilyType::
RoleClass () const
{
  return this->RoleClass_;
}

RoleFamilyType::RoleClass_sequence& RoleFamilyType::
RoleClass ()
{
  return this->RoleClass_;
}

void RoleFamilyType::
RoleClass (const RoleClass_sequence& s)
{
  this->RoleClass_ = s;
}


// SystemUnitClassType
// 

const SystemUnitClassType::Attribute_sequence& SystemUnitClassType::
Attribute () const
{
  return this->Attribute_;
}

SystemUnitClassType::Attribute_sequence& SystemUnitClassType::
Attribute ()
{
  return this->Attribute_;
}

void SystemUnitClassType::
Attribute (const Attribute_sequence& s)
{
  this->Attribute_ = s;
}

const SystemUnitClassType::ExternalInterface_sequence& SystemUnitClassType::
ExternalInterface () const
{
  return this->ExternalInterface_;
}

SystemUnitClassType::ExternalInterface_sequence& SystemUnitClassType::
ExternalInterface ()
{
  return this->ExternalInterface_;
}

void SystemUnitClassType::
ExternalInterface (const ExternalInterface_sequence& s)
{
  this->ExternalInterface_ = s;
}

const SystemUnitClassType::InternalElement_sequence& SystemUnitClassType::
InternalElement () const
{
  return this->InternalElement_;
}

SystemUnitClassType::InternalElement_sequence& SystemUnitClassType::
InternalElement ()
{
  return this->InternalElement_;
}

void SystemUnitClassType::
InternalElement (const InternalElement_sequence& s)
{
  this->InternalElement_ = s;
}

const SystemUnitClassType::SupportedRoleClass_sequence& SystemUnitClassType::
SupportedRoleClass () const
{
  return this->SupportedRoleClass_;
}

SystemUnitClassType::SupportedRoleClass_sequence& SystemUnitClassType::
SupportedRoleClass ()
{
  return this->SupportedRoleClass_;
}

void SystemUnitClassType::
SupportedRoleClass (const SupportedRoleClass_sequence& s)
{
  this->SupportedRoleClass_ = s;
}

const SystemUnitClassType::InternalLink_sequence& SystemUnitClassType::
InternalLink () const
{
  return this->InternalLink_;
}

SystemUnitClassType::InternalLink_sequence& SystemUnitClassType::
InternalLink ()
{
  return this->InternalLink_;
}

void SystemUnitClassType::
InternalLink (const InternalLink_sequence& s)
{
  this->InternalLink_ = s;
}


// SystemUnitFamilyType
// 

const SystemUnitFamilyType::SystemUnitClass_sequence& SystemUnitFamilyType::
SystemUnitClass () const
{
  return this->SystemUnitClass_;
}

SystemUnitFamilyType::SystemUnitClass_sequence& SystemUnitFamilyType::
SystemUnitClass ()
{
  return this->SystemUnitClass_;
}

void SystemUnitFamilyType::
SystemUnitClass (const SystemUnitClass_sequence& s)
{
  this->SystemUnitClass_ = s;
}

const SystemUnitFamilyType::RefBaseClassPath_optional& SystemUnitFamilyType::
RefBaseClassPath () const
{
  return this->RefBaseClassPath_;
}

SystemUnitFamilyType::RefBaseClassPath_optional& SystemUnitFamilyType::
RefBaseClassPath ()
{
  return this->RefBaseClassPath_;
}

void SystemUnitFamilyType::
RefBaseClassPath (const RefBaseClassPath_type& x)
{
  this->RefBaseClassPath_.set (x);
}

void SystemUnitFamilyType::
RefBaseClassPath (const RefBaseClassPath_optional& x)
{
  this->RefBaseClassPath_ = x;
}

void SystemUnitFamilyType::
RefBaseClassPath (::std::auto_ptr< RefBaseClassPath_type > x)
{
  this->RefBaseClassPath_.set (x);
}


// InternalElementType
// 

const InternalElementType::RoleRequirements_optional& InternalElementType::
RoleRequirements () const
{
  return this->RoleRequirements_;
}

InternalElementType::RoleRequirements_optional& InternalElementType::
RoleRequirements ()
{
  return this->RoleRequirements_;
}

void InternalElementType::
RoleRequirements (const RoleRequirements_type& x)
{
  this->RoleRequirements_.set (x);
}

void InternalElementType::
RoleRequirements (const RoleRequirements_optional& x)
{
  this->RoleRequirements_ = x;
}

void InternalElementType::
RoleRequirements (::std::auto_ptr< RoleRequirements_type > x)
{
  this->RoleRequirements_.set (x);
}

const InternalElementType::MappingObject_optional& InternalElementType::
MappingObject () const
{
  return this->MappingObject_;
}

InternalElementType::MappingObject_optional& InternalElementType::
MappingObject ()
{
  return this->MappingObject_;
}

void InternalElementType::
MappingObject (const MappingObject_type& x)
{
  this->MappingObject_.set (x);
}

void InternalElementType::
MappingObject (const MappingObject_optional& x)
{
  this->MappingObject_ = x;
}

void InternalElementType::
MappingObject (::std::auto_ptr< MappingObject_type > x)
{
  this->MappingObject_.set (x);
}

const InternalElementType::RefBaseSystemUnitPath_optional& InternalElementType::
RefBaseSystemUnitPath () const
{
  return this->RefBaseSystemUnitPath_;
}

InternalElementType::RefBaseSystemUnitPath_optional& InternalElementType::
RefBaseSystemUnitPath ()
{
  return this->RefBaseSystemUnitPath_;
}

void InternalElementType::
RefBaseSystemUnitPath (const RefBaseSystemUnitPath_type& x)
{
  this->RefBaseSystemUnitPath_.set (x);
}

void InternalElementType::
RefBaseSystemUnitPath (const RefBaseSystemUnitPath_optional& x)
{
  this->RefBaseSystemUnitPath_ = x;
}

void InternalElementType::
RefBaseSystemUnitPath (::std::auto_ptr< RefBaseSystemUnitPath_type > x)
{
  this->RefBaseSystemUnitPath_.set (x);
}


// AttributeType
// 

const AttributeType::DefaultValue_optional& AttributeType::
DefaultValue () const
{
  return this->DefaultValue_;
}

AttributeType::DefaultValue_optional& AttributeType::
DefaultValue ()
{
  return this->DefaultValue_;
}

void AttributeType::
DefaultValue (const DefaultValue_type& x)
{
  this->DefaultValue_.set (x);
}

void AttributeType::
DefaultValue (const DefaultValue_optional& x)
{
  this->DefaultValue_ = x;
}

void AttributeType::
DefaultValue (::std::auto_ptr< DefaultValue_type > x)
{
  this->DefaultValue_.set (x);
}

const AttributeType::Value_optional& AttributeType::
Value () const
{
  return this->Value_;
}

AttributeType::Value_optional& AttributeType::
Value ()
{
  return this->Value_;
}

void AttributeType::
Value (const Value_type& x)
{
  this->Value_.set (x);
}

void AttributeType::
Value (const Value_optional& x)
{
  this->Value_ = x;
}

void AttributeType::
Value (::std::auto_ptr< Value_type > x)
{
  this->Value_.set (x);
}

const AttributeType::RefSemantic_sequence& AttributeType::
RefSemantic () const
{
  return this->RefSemantic_;
}

AttributeType::RefSemantic_sequence& AttributeType::
RefSemantic ()
{
  return this->RefSemantic_;
}

void AttributeType::
RefSemantic (const RefSemantic_sequence& s)
{
  this->RefSemantic_ = s;
}

const AttributeType::Constraint_sequence& AttributeType::
Constraint () const
{
  return this->Constraint_;
}

AttributeType::Constraint_sequence& AttributeType::
Constraint ()
{
  return this->Constraint_;
}

void AttributeType::
Constraint (const Constraint_sequence& s)
{
  this->Constraint_ = s;
}

const AttributeType::Attribute_sequence& AttributeType::
Attribute () const
{
  return this->Attribute_;
}

AttributeType::Attribute_sequence& AttributeType::
Attribute ()
{
  return this->Attribute_;
}

void AttributeType::
Attribute (const Attribute_sequence& s)
{
  this->Attribute_ = s;
}

const AttributeType::Unit_optional& AttributeType::
Unit () const
{
  return this->Unit_;
}

AttributeType::Unit_optional& AttributeType::
Unit ()
{
  return this->Unit_;
}

void AttributeType::
Unit (const Unit_type& x)
{
  this->Unit_.set (x);
}

void AttributeType::
Unit (const Unit_optional& x)
{
  this->Unit_ = x;
}

void AttributeType::
Unit (::std::auto_ptr< Unit_type > x)
{
  this->Unit_.set (x);
}

const AttributeType::AttributeDataType_optional& AttributeType::
AttributeDataType () const
{
  return this->AttributeDataType_;
}

AttributeType::AttributeDataType_optional& AttributeType::
AttributeDataType ()
{
  return this->AttributeDataType_;
}

void AttributeType::
AttributeDataType (const AttributeDataType_type& x)
{
  this->AttributeDataType_.set (x);
}

void AttributeType::
AttributeDataType (const AttributeDataType_optional& x)
{
  this->AttributeDataType_ = x;
}

void AttributeType::
AttributeDataType (::std::auto_ptr< AttributeDataType_type > x)
{
  this->AttributeDataType_.set (x);
}


// AttributeValueRequirementType
// 

const AttributeValueRequirementType::OrdinalScaledType_optional& AttributeValueRequirementType::
OrdinalScaledType () const
{
  return this->OrdinalScaledType_;
}

AttributeValueRequirementType::OrdinalScaledType_optional& AttributeValueRequirementType::
OrdinalScaledType ()
{
  return this->OrdinalScaledType_;
}

void AttributeValueRequirementType::
OrdinalScaledType (const OrdinalScaledType_type& x)
{
  this->OrdinalScaledType_.set (x);
}

void AttributeValueRequirementType::
OrdinalScaledType (const OrdinalScaledType_optional& x)
{
  this->OrdinalScaledType_ = x;
}

void AttributeValueRequirementType::
OrdinalScaledType (::std::auto_ptr< OrdinalScaledType_type > x)
{
  this->OrdinalScaledType_.set (x);
}

const AttributeValueRequirementType::NominalScaledType_optional& AttributeValueRequirementType::
NominalScaledType () const
{
  return this->NominalScaledType_;
}

AttributeValueRequirementType::NominalScaledType_optional& AttributeValueRequirementType::
NominalScaledType ()
{
  return this->NominalScaledType_;
}

void AttributeValueRequirementType::
NominalScaledType (const NominalScaledType_type& x)
{
  this->NominalScaledType_.set (x);
}

void AttributeValueRequirementType::
NominalScaledType (const NominalScaledType_optional& x)
{
  this->NominalScaledType_ = x;
}

void AttributeValueRequirementType::
NominalScaledType (::std::auto_ptr< NominalScaledType_type > x)
{
  this->NominalScaledType_.set (x);
}

const AttributeValueRequirementType::UnknownType_optional& AttributeValueRequirementType::
UnknownType () const
{
  return this->UnknownType_;
}

AttributeValueRequirementType::UnknownType_optional& AttributeValueRequirementType::
UnknownType ()
{
  return this->UnknownType_;
}

void AttributeValueRequirementType::
UnknownType (const UnknownType_type& x)
{
  this->UnknownType_.set (x);
}

void AttributeValueRequirementType::
UnknownType (const UnknownType_optional& x)
{
  this->UnknownType_ = x;
}

void AttributeValueRequirementType::
UnknownType (::std::auto_ptr< UnknownType_type > x)
{
  this->UnknownType_.set (x);
}

const AttributeValueRequirementType::Name_type& AttributeValueRequirementType::
Name () const
{
  return this->Name_.get ();
}

AttributeValueRequirementType::Name_type& AttributeValueRequirementType::
Name ()
{
  return this->Name_.get ();
}

void AttributeValueRequirementType::
Name (const Name_type& x)
{
  this->Name_.set (x);
}

void AttributeValueRequirementType::
Name (::std::auto_ptr< Name_type > x)
{
  this->Name_.set (x);
}


// MappingType
// 

const MappingType::AttributeNameMapping_sequence& MappingType::
AttributeNameMapping () const
{
  return this->AttributeNameMapping_;
}

MappingType::AttributeNameMapping_sequence& MappingType::
AttributeNameMapping ()
{
  return this->AttributeNameMapping_;
}

void MappingType::
AttributeNameMapping (const AttributeNameMapping_sequence& s)
{
  this->AttributeNameMapping_ = s;
}

const MappingType::InterfaceNameMapping_sequence& MappingType::
InterfaceNameMapping () const
{
  return this->InterfaceNameMapping_;
}

MappingType::InterfaceNameMapping_sequence& MappingType::
InterfaceNameMapping ()
{
  return this->InterfaceNameMapping_;
}

void MappingType::
InterfaceNameMapping (const InterfaceNameMapping_sequence& s)
{
  this->InterfaceNameMapping_ = s;
}


// Description
// 

const Description::ChangeMode_type& Description::
ChangeMode () const
{
  return this->ChangeMode_.get ();
}

Description::ChangeMode_type& Description::
ChangeMode ()
{
  return this->ChangeMode_.get ();
}

void Description::
ChangeMode (const ChangeMode_type& x)
{
  this->ChangeMode_.set (x);
}

void Description::
ChangeMode (::std::auto_ptr< ChangeMode_type > x)
{
  this->ChangeMode_.set (x);
}

const Description::ChangeMode_type& Description::
ChangeMode_default_value ()
{
  return ChangeMode_default_value_;
}


// Version
// 

const Version::ChangeMode_type& Version::
ChangeMode () const
{
  return this->ChangeMode_.get ();
}

Version::ChangeMode_type& Version::
ChangeMode ()
{
  return this->ChangeMode_.get ();
}

void Version::
ChangeMode (const ChangeMode_type& x)
{
  this->ChangeMode_.set (x);
}

void Version::
ChangeMode (::std::auto_ptr< ChangeMode_type > x)
{
  this->ChangeMode_.set (x);
}

const Version::ChangeMode_type& Version::
ChangeMode_default_value ()
{
  return ChangeMode_default_value_;
}


// Revision
// 

const Revision::RevisionDate_type& Revision::
RevisionDate () const
{
  return this->RevisionDate_.get ();
}

Revision::RevisionDate_type& Revision::
RevisionDate ()
{
  return this->RevisionDate_.get ();
}

void Revision::
RevisionDate (const RevisionDate_type& x)
{
  this->RevisionDate_.set (x);
}

void Revision::
RevisionDate (::std::auto_ptr< RevisionDate_type > x)
{
  this->RevisionDate_.set (x);
}

const Revision::OldVersion_optional& Revision::
OldVersion () const
{
  return this->OldVersion_;
}

Revision::OldVersion_optional& Revision::
OldVersion ()
{
  return this->OldVersion_;
}

void Revision::
OldVersion (const OldVersion_type& x)
{
  this->OldVersion_.set (x);
}

void Revision::
OldVersion (const OldVersion_optional& x)
{
  this->OldVersion_ = x;
}

void Revision::
OldVersion (::std::auto_ptr< OldVersion_type > x)
{
  this->OldVersion_.set (x);
}

const Revision::NewVersion_optional& Revision::
NewVersion () const
{
  return this->NewVersion_;
}

Revision::NewVersion_optional& Revision::
NewVersion ()
{
  return this->NewVersion_;
}

void Revision::
NewVersion (const NewVersion_type& x)
{
  this->NewVersion_.set (x);
}

void Revision::
NewVersion (const NewVersion_optional& x)
{
  this->NewVersion_ = x;
}

void Revision::
NewVersion (::std::auto_ptr< NewVersion_type > x)
{
  this->NewVersion_.set (x);
}

const Revision::AuthorName_type& Revision::
AuthorName () const
{
  return this->AuthorName_.get ();
}

Revision::AuthorName_type& Revision::
AuthorName ()
{
  return this->AuthorName_.get ();
}

void Revision::
AuthorName (const AuthorName_type& x)
{
  this->AuthorName_.set (x);
}

void Revision::
AuthorName (::std::auto_ptr< AuthorName_type > x)
{
  this->AuthorName_.set (x);
}

const Revision::Comment_optional& Revision::
Comment () const
{
  return this->Comment_;
}

Revision::Comment_optional& Revision::
Comment ()
{
  return this->Comment_;
}

void Revision::
Comment (const Comment_type& x)
{
  this->Comment_.set (x);
}

void Revision::
Comment (const Comment_optional& x)
{
  this->Comment_ = x;
}

void Revision::
Comment (::std::auto_ptr< Comment_type > x)
{
  this->Comment_.set (x);
}


// Copyright
// 

const Copyright::ChangeMode_type& Copyright::
ChangeMode () const
{
  return this->ChangeMode_.get ();
}

Copyright::ChangeMode_type& Copyright::
ChangeMode ()
{
  return this->ChangeMode_.get ();
}

void Copyright::
ChangeMode (const ChangeMode_type& x)
{
  this->ChangeMode_.set (x);
}

void Copyright::
ChangeMode (::std::auto_ptr< ChangeMode_type > x)
{
  this->ChangeMode_.set (x);
}

const Copyright::ChangeMode_type& Copyright::
ChangeMode_default_value ()
{
  return ChangeMode_default_value_;
}


// ExternalInterface
// 


// SupportedRoleClass
// 

const SupportedRoleClass::MappingObject_optional& SupportedRoleClass::
MappingObject () const
{
  return this->MappingObject_;
}

SupportedRoleClass::MappingObject_optional& SupportedRoleClass::
MappingObject ()
{
  return this->MappingObject_;
}

void SupportedRoleClass::
MappingObject (const MappingObject_type& x)
{
  this->MappingObject_.set (x);
}

void SupportedRoleClass::
MappingObject (const MappingObject_optional& x)
{
  this->MappingObject_ = x;
}

void SupportedRoleClass::
MappingObject (::std::auto_ptr< MappingObject_type > x)
{
  this->MappingObject_.set (x);
}

const SupportedRoleClass::RefRoleClassPath_type& SupportedRoleClass::
RefRoleClassPath () const
{
  return this->RefRoleClassPath_.get ();
}

SupportedRoleClass::RefRoleClassPath_type& SupportedRoleClass::
RefRoleClassPath ()
{
  return this->RefRoleClassPath_.get ();
}

void SupportedRoleClass::
RefRoleClassPath (const RefRoleClassPath_type& x)
{
  this->RefRoleClassPath_.set (x);
}

void SupportedRoleClass::
RefRoleClassPath (::std::auto_ptr< RefRoleClassPath_type > x)
{
  this->RefRoleClassPath_.set (x);
}


// InternalLink
// 

const InternalLink::RefPartnerSideA_optional& InternalLink::
RefPartnerSideA () const
{
  return this->RefPartnerSideA_;
}

InternalLink::RefPartnerSideA_optional& InternalLink::
RefPartnerSideA ()
{
  return this->RefPartnerSideA_;
}

void InternalLink::
RefPartnerSideA (const RefPartnerSideA_type& x)
{
  this->RefPartnerSideA_.set (x);
}

void InternalLink::
RefPartnerSideA (const RefPartnerSideA_optional& x)
{
  this->RefPartnerSideA_ = x;
}

void InternalLink::
RefPartnerSideA (::std::auto_ptr< RefPartnerSideA_type > x)
{
  this->RefPartnerSideA_.set (x);
}

const InternalLink::RefPartnerSideB_optional& InternalLink::
RefPartnerSideB () const
{
  return this->RefPartnerSideB_;
}

InternalLink::RefPartnerSideB_optional& InternalLink::
RefPartnerSideB ()
{
  return this->RefPartnerSideB_;
}

void InternalLink::
RefPartnerSideB (const RefPartnerSideB_type& x)
{
  this->RefPartnerSideB_.set (x);
}

void InternalLink::
RefPartnerSideB (const RefPartnerSideB_optional& x)
{
  this->RefPartnerSideB_ = x;
}

void InternalLink::
RefPartnerSideB (::std::auto_ptr< RefPartnerSideB_type > x)
{
  this->RefPartnerSideB_.set (x);
}


// RoleRequirements
// 

const RoleRequirements::Attribute_sequence& RoleRequirements::
Attribute () const
{
  return this->Attribute_;
}

RoleRequirements::Attribute_sequence& RoleRequirements::
Attribute ()
{
  return this->Attribute_;
}

void RoleRequirements::
Attribute (const Attribute_sequence& s)
{
  this->Attribute_ = s;
}

const RoleRequirements::ExternalInterface_sequence& RoleRequirements::
ExternalInterface () const
{
  return this->ExternalInterface_;
}

RoleRequirements::ExternalInterface_sequence& RoleRequirements::
ExternalInterface ()
{
  return this->ExternalInterface_;
}

void RoleRequirements::
ExternalInterface (const ExternalInterface_sequence& s)
{
  this->ExternalInterface_ = s;
}

const RoleRequirements::RefBaseRoleClassPath_optional& RoleRequirements::
RefBaseRoleClassPath () const
{
  return this->RefBaseRoleClassPath_;
}

RoleRequirements::RefBaseRoleClassPath_optional& RoleRequirements::
RefBaseRoleClassPath ()
{
  return this->RefBaseRoleClassPath_;
}

void RoleRequirements::
RefBaseRoleClassPath (const RefBaseRoleClassPath_type& x)
{
  this->RefBaseRoleClassPath_.set (x);
}

void RoleRequirements::
RefBaseRoleClassPath (const RefBaseRoleClassPath_optional& x)
{
  this->RefBaseRoleClassPath_ = x;
}

void RoleRequirements::
RefBaseRoleClassPath (::std::auto_ptr< RefBaseRoleClassPath_type > x)
{
  this->RefBaseRoleClassPath_.set (x);
}


// RefSemantic
// 

const RefSemantic::CorrespondingAttributePath_type& RefSemantic::
CorrespondingAttributePath () const
{
  return this->CorrespondingAttributePath_.get ();
}

RefSemantic::CorrespondingAttributePath_type& RefSemantic::
CorrespondingAttributePath ()
{
  return this->CorrespondingAttributePath_.get ();
}

void RefSemantic::
CorrespondingAttributePath (const CorrespondingAttributePath_type& x)
{
  this->CorrespondingAttributePath_.set (x);
}

void RefSemantic::
CorrespondingAttributePath (::std::auto_ptr< CorrespondingAttributePath_type > x)
{
  this->CorrespondingAttributePath_.set (x);
}


// AttributeDataType
// 


// OrdinalScaledType
// 

const OrdinalScaledType::RequiredMaxValue_optional& OrdinalScaledType::
RequiredMaxValue () const
{
  return this->RequiredMaxValue_;
}

OrdinalScaledType::RequiredMaxValue_optional& OrdinalScaledType::
RequiredMaxValue ()
{
  return this->RequiredMaxValue_;
}

void OrdinalScaledType::
RequiredMaxValue (const RequiredMaxValue_type& x)
{
  this->RequiredMaxValue_.set (x);
}

void OrdinalScaledType::
RequiredMaxValue (const RequiredMaxValue_optional& x)
{
  this->RequiredMaxValue_ = x;
}

void OrdinalScaledType::
RequiredMaxValue (::std::auto_ptr< RequiredMaxValue_type > x)
{
  this->RequiredMaxValue_.set (x);
}

const OrdinalScaledType::RequiredValue_optional& OrdinalScaledType::
RequiredValue () const
{
  return this->RequiredValue_;
}

OrdinalScaledType::RequiredValue_optional& OrdinalScaledType::
RequiredValue ()
{
  return this->RequiredValue_;
}

void OrdinalScaledType::
RequiredValue (const RequiredValue_type& x)
{
  this->RequiredValue_.set (x);
}

void OrdinalScaledType::
RequiredValue (const RequiredValue_optional& x)
{
  this->RequiredValue_ = x;
}

void OrdinalScaledType::
RequiredValue (::std::auto_ptr< RequiredValue_type > x)
{
  this->RequiredValue_.set (x);
}

const OrdinalScaledType::RequiredMinValue_optional& OrdinalScaledType::
RequiredMinValue () const
{
  return this->RequiredMinValue_;
}

OrdinalScaledType::RequiredMinValue_optional& OrdinalScaledType::
RequiredMinValue ()
{
  return this->RequiredMinValue_;
}

void OrdinalScaledType::
RequiredMinValue (const RequiredMinValue_type& x)
{
  this->RequiredMinValue_.set (x);
}

void OrdinalScaledType::
RequiredMinValue (const RequiredMinValue_optional& x)
{
  this->RequiredMinValue_ = x;
}

void OrdinalScaledType::
RequiredMinValue (::std::auto_ptr< RequiredMinValue_type > x)
{
  this->RequiredMinValue_.set (x);
}


// NominalScaledType
// 

const NominalScaledType::RequiredValue_sequence& NominalScaledType::
RequiredValue () const
{
  return this->RequiredValue_;
}

NominalScaledType::RequiredValue_sequence& NominalScaledType::
RequiredValue ()
{
  return this->RequiredValue_;
}

void NominalScaledType::
RequiredValue (const RequiredValue_sequence& s)
{
  this->RequiredValue_ = s;
}


// UnknownType
// 

const UnknownType::Requirements_optional& UnknownType::
Requirements () const
{
  return this->Requirements_;
}

UnknownType::Requirements_optional& UnknownType::
Requirements ()
{
  return this->Requirements_;
}

void UnknownType::
Requirements (const Requirements_type& x)
{
  this->Requirements_.set (x);
}

void UnknownType::
Requirements (const Requirements_optional& x)
{
  this->Requirements_ = x;
}

void UnknownType::
Requirements (::std::auto_ptr< Requirements_type > x)
{
  this->Requirements_.set (x);
}


// AttributeNameMapping
// 

const AttributeNameMapping::SystemUnitAttributeName_type& AttributeNameMapping::
SystemUnitAttributeName () const
{
  return this->SystemUnitAttributeName_.get ();
}

AttributeNameMapping::SystemUnitAttributeName_type& AttributeNameMapping::
SystemUnitAttributeName ()
{
  return this->SystemUnitAttributeName_.get ();
}

void AttributeNameMapping::
SystemUnitAttributeName (const SystemUnitAttributeName_type& x)
{
  this->SystemUnitAttributeName_.set (x);
}

void AttributeNameMapping::
SystemUnitAttributeName (::std::auto_ptr< SystemUnitAttributeName_type > x)
{
  this->SystemUnitAttributeName_.set (x);
}

const AttributeNameMapping::RoleAttributeName_type& AttributeNameMapping::
RoleAttributeName () const
{
  return this->RoleAttributeName_.get ();
}

AttributeNameMapping::RoleAttributeName_type& AttributeNameMapping::
RoleAttributeName ()
{
  return this->RoleAttributeName_.get ();
}

void AttributeNameMapping::
RoleAttributeName (const RoleAttributeName_type& x)
{
  this->RoleAttributeName_.set (x);
}

void AttributeNameMapping::
RoleAttributeName (::std::auto_ptr< RoleAttributeName_type > x)
{
  this->RoleAttributeName_.set (x);
}


// InterfaceNameMapping
// 

const InterfaceNameMapping::SystemUnitInterfaceName_type& InterfaceNameMapping::
SystemUnitInterfaceName () const
{
  return this->SystemUnitInterfaceName_.get ();
}

InterfaceNameMapping::SystemUnitInterfaceName_type& InterfaceNameMapping::
SystemUnitInterfaceName ()
{
  return this->SystemUnitInterfaceName_.get ();
}

void InterfaceNameMapping::
SystemUnitInterfaceName (const SystemUnitInterfaceName_type& x)
{
  this->SystemUnitInterfaceName_.set (x);
}

void InterfaceNameMapping::
SystemUnitInterfaceName (::std::auto_ptr< SystemUnitInterfaceName_type > x)
{
  this->SystemUnitInterfaceName_.set (x);
}

const InterfaceNameMapping::RoleInterfaceName_type& InterfaceNameMapping::
RoleInterfaceName () const
{
  return this->RoleInterfaceName_.get ();
}

InterfaceNameMapping::RoleInterfaceName_type& InterfaceNameMapping::
RoleInterfaceName ()
{
  return this->RoleInterfaceName_.get ();
}

void InterfaceNameMapping::
RoleInterfaceName (const RoleInterfaceName_type& x)
{
  this->RoleInterfaceName_.set (x);
}

void InterfaceNameMapping::
RoleInterfaceName (::std::auto_ptr< RoleInterfaceName_type > x)
{
  this->RoleInterfaceName_.set (x);
}


// CAEXFile
// 

const CAEXFile::ExternalReference_sequence& CAEXFile::
ExternalReference () const
{
  return this->ExternalReference_;
}

CAEXFile::ExternalReference_sequence& CAEXFile::
ExternalReference ()
{
  return this->ExternalReference_;
}

void CAEXFile::
ExternalReference (const ExternalReference_sequence& s)
{
  this->ExternalReference_ = s;
}

const CAEXFile::InstanceHierarchy_sequence& CAEXFile::
InstanceHierarchy () const
{
  return this->InstanceHierarchy_;
}

CAEXFile::InstanceHierarchy_sequence& CAEXFile::
InstanceHierarchy ()
{
  return this->InstanceHierarchy_;
}

void CAEXFile::
InstanceHierarchy (const InstanceHierarchy_sequence& s)
{
  this->InstanceHierarchy_ = s;
}

const CAEXFile::InterfaceClassLib_sequence& CAEXFile::
InterfaceClassLib () const
{
  return this->InterfaceClassLib_;
}

CAEXFile::InterfaceClassLib_sequence& CAEXFile::
InterfaceClassLib ()
{
  return this->InterfaceClassLib_;
}

void CAEXFile::
InterfaceClassLib (const InterfaceClassLib_sequence& s)
{
  this->InterfaceClassLib_ = s;
}

const CAEXFile::RoleClassLib_sequence& CAEXFile::
RoleClassLib () const
{
  return this->RoleClassLib_;
}

CAEXFile::RoleClassLib_sequence& CAEXFile::
RoleClassLib ()
{
  return this->RoleClassLib_;
}

void CAEXFile::
RoleClassLib (const RoleClassLib_sequence& s)
{
  this->RoleClassLib_ = s;
}

const CAEXFile::SystemUnitClassLib_sequence& CAEXFile::
SystemUnitClassLib () const
{
  return this->SystemUnitClassLib_;
}

CAEXFile::SystemUnitClassLib_sequence& CAEXFile::
SystemUnitClassLib ()
{
  return this->SystemUnitClassLib_;
}

void CAEXFile::
SystemUnitClassLib (const SystemUnitClassLib_sequence& s)
{
  this->SystemUnitClassLib_ = s;
}

const CAEXFile::FileName_type& CAEXFile::
FileName () const
{
  return this->FileName_.get ();
}

CAEXFile::FileName_type& CAEXFile::
FileName ()
{
  return this->FileName_.get ();
}

void CAEXFile::
FileName (const FileName_type& x)
{
  this->FileName_.set (x);
}

void CAEXFile::
FileName (::std::auto_ptr< FileName_type > x)
{
  this->FileName_.set (x);
}

const CAEXFile::SchemaVersion_type& CAEXFile::
SchemaVersion () const
{
  return this->SchemaVersion_.get ();
}

const CAEXFile::SchemaVersion_type& CAEXFile::
SchemaVersion_default_value ()
{
  return SchemaVersion_default_value_;
}


// ExternalReference
// 

const ExternalReference::Path_type& ExternalReference::
Path () const
{
  return this->Path_.get ();
}

ExternalReference::Path_type& ExternalReference::
Path ()
{
  return this->Path_.get ();
}

void ExternalReference::
Path (const Path_type& x)
{
  this->Path_.set (x);
}

void ExternalReference::
Path (::std::auto_ptr< Path_type > x)
{
  this->Path_.set (x);
}

const ExternalReference::Alias_type& ExternalReference::
Alias () const
{
  return this->Alias_.get ();
}

ExternalReference::Alias_type& ExternalReference::
Alias ()
{
  return this->Alias_.get ();
}

void ExternalReference::
Alias (const Alias_type& x)
{
  this->Alias_.set (x);
}

void ExternalReference::
Alias (::std::auto_ptr< Alias_type > x)
{
  this->Alias_.set (x);
}


// InstanceHierarchy
// 

const InstanceHierarchy::InternalElement_sequence& InstanceHierarchy::
InternalElement () const
{
  return this->InternalElement_;
}

InstanceHierarchy::InternalElement_sequence& InstanceHierarchy::
InternalElement ()
{
  return this->InternalElement_;
}

void InstanceHierarchy::
InternalElement (const InternalElement_sequence& s)
{
  this->InternalElement_ = s;
}


// InterfaceClassLib
// 

const InterfaceClassLib::InterfaceClass_sequence& InterfaceClassLib::
InterfaceClass () const
{
  return this->InterfaceClass_;
}

InterfaceClassLib::InterfaceClass_sequence& InterfaceClassLib::
InterfaceClass ()
{
  return this->InterfaceClass_;
}

void InterfaceClassLib::
InterfaceClass (const InterfaceClass_sequence& s)
{
  this->InterfaceClass_ = s;
}


// RoleClassLib
// 

const RoleClassLib::RoleClass_sequence& RoleClassLib::
RoleClass () const
{
  return this->RoleClass_;
}

RoleClassLib::RoleClass_sequence& RoleClassLib::
RoleClass ()
{
  return this->RoleClass_;
}

void RoleClassLib::
RoleClass (const RoleClass_sequence& s)
{
  this->RoleClass_ = s;
}


// SystemUnitClassLib
// 

const SystemUnitClassLib::SystemUnitClass_sequence& SystemUnitClassLib::
SystemUnitClass () const
{
  return this->SystemUnitClass_;
}

SystemUnitClassLib::SystemUnitClass_sequence& SystemUnitClassLib::
SystemUnitClass ()
{
  return this->SystemUnitClass_;
}

void SystemUnitClassLib::
SystemUnitClass (const SystemUnitClass_sequence& s)
{
  this->SystemUnitClass_ = s;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// ChangeMode
//

ChangeMode::
ChangeMode (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_ChangeMode_convert ();
}

ChangeMode::
ChangeMode (const ::xercesc::DOMAttr& a,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_ChangeMode_convert ();
}

ChangeMode::
ChangeMode (const ::std::string& s,
            const ::xercesc::DOMElement* e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_ChangeMode_convert ();
}

ChangeMode* ChangeMode::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ChangeMode (*this, f, c);
}

ChangeMode::value ChangeMode::
_xsd_ChangeMode_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_ChangeMode_literals_);
  const value* i (::std::lower_bound (
                    _xsd_ChangeMode_indexes_,
                    _xsd_ChangeMode_indexes_ + 4,
                    *this,
                    c));

  if (i == _xsd_ChangeMode_indexes_ + 4 || _xsd_ChangeMode_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const ChangeMode::
_xsd_ChangeMode_literals_[4] =
{
  "state",
  "create",
  "delete",
  "change"
};

const ChangeMode::value ChangeMode::
_xsd_ChangeMode_indexes_[4] =
{
  ::ChangeMode::change,
  ::ChangeMode::create,
  ::ChangeMode::delete_,
  ::ChangeMode::state
};

// CAEXBasicObject
//

const CAEXBasicObject::ChangeMode_type CAEXBasicObject::ChangeMode_default_value_ (
  "state");

CAEXBasicObject::
CAEXBasicObject ()
: ::xml_schema::type (),
  Description_ (this),
  Version_ (this),
  Revision_ (this),
  Copyright_ (this),
  AdditionalInformation_ (this),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

CAEXBasicObject::
CAEXBasicObject (const CAEXBasicObject& x,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Description_ (x.Description_, f, this),
  Version_ (x.Version_, f, this),
  Revision_ (x.Revision_, f, this),
  Copyright_ (x.Copyright_, f, this),
  AdditionalInformation_ (x.AdditionalInformation_, f, this),
  ChangeMode_ (x.ChangeMode_, f, this)
{
}

CAEXBasicObject::
CAEXBasicObject (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f,
                 ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Description_ (this),
  Version_ (this),
  Revision_ (this),
  Copyright_ (this),
  AdditionalInformation_ (this),
  ChangeMode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void CAEXBasicObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Description
    //
    if (n.name () == "Description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Description_type > r (
        Description_traits::create (i, f, this));

      if (!this->Description_)
      {
        this->Description_.set (r);
        continue;
      }
    }

    // Version
    //
    if (n.name () == "Version" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Version_type > r (
        Version_traits::create (i, f, this));

      if (!this->Version_)
      {
        this->Version_.set (r);
        continue;
      }
    }

    // Revision
    //
    if (n.name () == "Revision" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Revision_type > r (
        Revision_traits::create (i, f, this));

      this->Revision_.push_back (r);
      continue;
    }

    // Copyright
    //
    if (n.name () == "Copyright" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Copyright_type > r (
        Copyright_traits::create (i, f, this));

      if (!this->Copyright_)
      {
        this->Copyright_.set (r);
        continue;
      }
    }

    // AdditionalInformation
    //
    if (n.name () == "AdditionalInformation" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AdditionalInformation_type > r (
        AdditionalInformation_traits::create (i, f, this));

      this->AdditionalInformation_.push_back (r);
      continue;
    }

    break;
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ChangeMode" && n.namespace_ ().empty ())
    {
      this->ChangeMode_.set (ChangeMode_traits::create (i, f, this));
      continue;
    }
  }

  if (!ChangeMode_.present ())
  {
    this->ChangeMode_.set (ChangeMode_default_value ());
  }
}

CAEXBasicObject* CAEXBasicObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CAEXBasicObject (*this, f, c);
}

CAEXBasicObject& CAEXBasicObject::
operator= (const CAEXBasicObject& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Description_ = x.Description_;
    this->Version_ = x.Version_;
    this->Revision_ = x.Revision_;
    this->Copyright_ = x.Copyright_;
    this->AdditionalInformation_ = x.AdditionalInformation_;
    this->ChangeMode_ = x.ChangeMode_;
  }

  return *this;
}

CAEXBasicObject::
~CAEXBasicObject ()
{
}

// CAEXObject
//

CAEXObject::
CAEXObject (const Name_type& Name)
: ::CAEXBasicObject (),
  ID_ (this),
  Name_ (Name, this)
{
}

CAEXObject::
CAEXObject (const CAEXObject& x,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  ID_ (x.ID_, f, this),
  Name_ (x.Name_, f, this)
{
}

CAEXObject::
CAEXObject (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  ID_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void CAEXObject::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ID" && n.namespace_ ().empty ())
    {
      this->ID_.set (ID_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Name",
      "");
  }
}

CAEXObject* CAEXObject::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CAEXObject (*this, f, c);
}

CAEXObject& CAEXObject::
operator= (const CAEXObject& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->ID_ = x.ID_;
    this->Name_ = x.Name_;
  }

  return *this;
}

CAEXObject::
~CAEXObject ()
{
}

// InterfaceClassType
//

InterfaceClassType::
InterfaceClassType (const Name_type& Name)
: ::CAEXObject (Name),
  Attribute_ (this),
  RefBaseClassPath_ (this)
{
}

InterfaceClassType::
InterfaceClassType (const InterfaceClassType& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  Attribute_ (x.Attribute_, f, this),
  RefBaseClassPath_ (x.RefBaseClassPath_, f, this)
{
}

InterfaceClassType::
InterfaceClassType (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  Attribute_ (this),
  RefBaseClassPath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InterfaceClassType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Attribute
    //
    if (n.name () == "Attribute" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attribute_type > r (
        Attribute_traits::create (i, f, this));

      this->Attribute_.push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefBaseClassPath" && n.namespace_ ().empty ())
    {
      this->RefBaseClassPath_.set (RefBaseClassPath_traits::create (i, f, this));
      continue;
    }
  }
}

InterfaceClassType* InterfaceClassType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InterfaceClassType (*this, f, c);
}

InterfaceClassType& InterfaceClassType::
operator= (const InterfaceClassType& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->Attribute_ = x.Attribute_;
    this->RefBaseClassPath_ = x.RefBaseClassPath_;
  }

  return *this;
}

InterfaceClassType::
~InterfaceClassType ()
{
}

// InterfaceFamilyType
//

InterfaceFamilyType::
InterfaceFamilyType (const Name_type& Name)
: ::InterfaceClassType (Name),
  InterfaceClass_ (this)
{
}

InterfaceFamilyType::
InterfaceFamilyType (const InterfaceFamilyType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::InterfaceClassType (x, f, c),
  InterfaceClass_ (x.InterfaceClass_, f, this)
{
}

InterfaceFamilyType::
InterfaceFamilyType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::InterfaceClassType (e, f | ::xml_schema::flags::base, c),
  InterfaceClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InterfaceFamilyType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::InterfaceClassType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // InterfaceClass
    //
    if (n.name () == "InterfaceClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InterfaceClass_type > r (
        InterfaceClass_traits::create (i, f, this));

      this->InterfaceClass_.push_back (r);
      continue;
    }

    break;
  }
}

InterfaceFamilyType* InterfaceFamilyType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InterfaceFamilyType (*this, f, c);
}

InterfaceFamilyType& InterfaceFamilyType::
operator= (const InterfaceFamilyType& x)
{
  if (this != &x)
  {
    static_cast< ::InterfaceClassType& > (*this) = x;
    this->InterfaceClass_ = x.InterfaceClass_;
  }

  return *this;
}

InterfaceFamilyType::
~InterfaceFamilyType ()
{
}

// RoleClassType
//

RoleClassType::
RoleClassType (const Name_type& Name)
: ::CAEXObject (Name),
  Attribute_ (this),
  ExternalInterface_ (this),
  RefBaseClassPath_ (this)
{
}

RoleClassType::
RoleClassType (const RoleClassType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  Attribute_ (x.Attribute_, f, this),
  ExternalInterface_ (x.ExternalInterface_, f, this),
  RefBaseClassPath_ (x.RefBaseClassPath_, f, this)
{
}

RoleClassType::
RoleClassType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  Attribute_ (this),
  ExternalInterface_ (this),
  RefBaseClassPath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RoleClassType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Attribute
    //
    if (n.name () == "Attribute" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attribute_type > r (
        Attribute_traits::create (i, f, this));

      this->Attribute_.push_back (r);
      continue;
    }

    // ExternalInterface
    //
    if (n.name () == "ExternalInterface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ExternalInterface_type > r (
        ExternalInterface_traits::create (i, f, this));

      this->ExternalInterface_.push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefBaseClassPath" && n.namespace_ ().empty ())
    {
      this->RefBaseClassPath_.set (RefBaseClassPath_traits::create (i, f, this));
      continue;
    }
  }
}

RoleClassType* RoleClassType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RoleClassType (*this, f, c);
}

RoleClassType& RoleClassType::
operator= (const RoleClassType& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->Attribute_ = x.Attribute_;
    this->ExternalInterface_ = x.ExternalInterface_;
    this->RefBaseClassPath_ = x.RefBaseClassPath_;
  }

  return *this;
}

RoleClassType::
~RoleClassType ()
{
}

// RoleFamilyType
//

RoleFamilyType::
RoleFamilyType (const Name_type& Name)
: ::RoleClassType (Name),
  RoleClass_ (this)
{
}

RoleFamilyType::
RoleFamilyType (const RoleFamilyType& x,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::RoleClassType (x, f, c),
  RoleClass_ (x.RoleClass_, f, this)
{
}

RoleFamilyType::
RoleFamilyType (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::container* c)
: ::RoleClassType (e, f | ::xml_schema::flags::base, c),
  RoleClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RoleFamilyType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::RoleClassType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RoleClass
    //
    if (n.name () == "RoleClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RoleClass_type > r (
        RoleClass_traits::create (i, f, this));

      this->RoleClass_.push_back (r);
      continue;
    }

    break;
  }
}

RoleFamilyType* RoleFamilyType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RoleFamilyType (*this, f, c);
}

RoleFamilyType& RoleFamilyType::
operator= (const RoleFamilyType& x)
{
  if (this != &x)
  {
    static_cast< ::RoleClassType& > (*this) = x;
    this->RoleClass_ = x.RoleClass_;
  }

  return *this;
}

RoleFamilyType::
~RoleFamilyType ()
{
}

// SystemUnitClassType
//

SystemUnitClassType::
SystemUnitClassType (const Name_type& Name)
: ::CAEXObject (Name),
  Attribute_ (this),
  ExternalInterface_ (this),
  InternalElement_ (this),
  SupportedRoleClass_ (this),
  InternalLink_ (this)
{
}

SystemUnitClassType::
SystemUnitClassType (const SystemUnitClassType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  Attribute_ (x.Attribute_, f, this),
  ExternalInterface_ (x.ExternalInterface_, f, this),
  InternalElement_ (x.InternalElement_, f, this),
  SupportedRoleClass_ (x.SupportedRoleClass_, f, this),
  InternalLink_ (x.InternalLink_, f, this)
{
}

SystemUnitClassType::
SystemUnitClassType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  Attribute_ (this),
  ExternalInterface_ (this),
  InternalElement_ (this),
  SupportedRoleClass_ (this),
  InternalLink_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SystemUnitClassType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Attribute
    //
    if (n.name () == "Attribute" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attribute_type > r (
        Attribute_traits::create (i, f, this));

      this->Attribute_.push_back (r);
      continue;
    }

    // ExternalInterface
    //
    if (n.name () == "ExternalInterface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ExternalInterface_type > r (
        ExternalInterface_traits::create (i, f, this));

      this->ExternalInterface_.push_back (r);
      continue;
    }

    // InternalElement
    //
    if (n.name () == "InternalElement" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InternalElement_type > r (
        InternalElement_traits::create (i, f, this));

      this->InternalElement_.push_back (r);
      continue;
    }

    // SupportedRoleClass
    //
    if (n.name () == "SupportedRoleClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SupportedRoleClass_type > r (
        SupportedRoleClass_traits::create (i, f, this));

      this->SupportedRoleClass_.push_back (r);
      continue;
    }

    // InternalLink
    //
    if (n.name () == "InternalLink" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InternalLink_type > r (
        InternalLink_traits::create (i, f, this));

      this->InternalLink_.push_back (r);
      continue;
    }

    break;
  }
}

SystemUnitClassType* SystemUnitClassType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SystemUnitClassType (*this, f, c);
}

SystemUnitClassType& SystemUnitClassType::
operator= (const SystemUnitClassType& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->Attribute_ = x.Attribute_;
    this->ExternalInterface_ = x.ExternalInterface_;
    this->InternalElement_ = x.InternalElement_;
    this->SupportedRoleClass_ = x.SupportedRoleClass_;
    this->InternalLink_ = x.InternalLink_;
  }

  return *this;
}

SystemUnitClassType::
~SystemUnitClassType ()
{
}

// SystemUnitFamilyType
//

SystemUnitFamilyType::
SystemUnitFamilyType (const Name_type& Name)
: ::SystemUnitClassType (Name),
  SystemUnitClass_ (this),
  RefBaseClassPath_ (this)
{
}

SystemUnitFamilyType::
SystemUnitFamilyType (const SystemUnitFamilyType& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::SystemUnitClassType (x, f, c),
  SystemUnitClass_ (x.SystemUnitClass_, f, this),
  RefBaseClassPath_ (x.RefBaseClassPath_, f, this)
{
}

SystemUnitFamilyType::
SystemUnitFamilyType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::SystemUnitClassType (e, f | ::xml_schema::flags::base, c),
  SystemUnitClass_ (this),
  RefBaseClassPath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SystemUnitFamilyType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::SystemUnitClassType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SystemUnitClass
    //
    if (n.name () == "SystemUnitClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SystemUnitClass_type > r (
        SystemUnitClass_traits::create (i, f, this));

      this->SystemUnitClass_.push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefBaseClassPath" && n.namespace_ ().empty ())
    {
      this->RefBaseClassPath_.set (RefBaseClassPath_traits::create (i, f, this));
      continue;
    }
  }
}

SystemUnitFamilyType* SystemUnitFamilyType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SystemUnitFamilyType (*this, f, c);
}

SystemUnitFamilyType& SystemUnitFamilyType::
operator= (const SystemUnitFamilyType& x)
{
  if (this != &x)
  {
    static_cast< ::SystemUnitClassType& > (*this) = x;
    this->SystemUnitClass_ = x.SystemUnitClass_;
    this->RefBaseClassPath_ = x.RefBaseClassPath_;
  }

  return *this;
}

SystemUnitFamilyType::
~SystemUnitFamilyType ()
{
}

// InternalElementType
//

InternalElementType::
InternalElementType (const Name_type& Name)
: ::SystemUnitClassType (Name),
  RoleRequirements_ (this),
  MappingObject_ (this),
  RefBaseSystemUnitPath_ (this)
{
}

InternalElementType::
InternalElementType (const InternalElementType& x,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::SystemUnitClassType (x, f, c),
  RoleRequirements_ (x.RoleRequirements_, f, this),
  MappingObject_ (x.MappingObject_, f, this),
  RefBaseSystemUnitPath_ (x.RefBaseSystemUnitPath_, f, this)
{
}

InternalElementType::
InternalElementType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f,
                     ::xml_schema::container* c)
: ::SystemUnitClassType (e, f | ::xml_schema::flags::base, c),
  RoleRequirements_ (this),
  MappingObject_ (this),
  RefBaseSystemUnitPath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InternalElementType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::SystemUnitClassType::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RoleRequirements
    //
    if (n.name () == "RoleRequirements" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RoleRequirements_type > r (
        RoleRequirements_traits::create (i, f, this));

      if (!this->RoleRequirements_)
      {
        this->RoleRequirements_.set (r);
        continue;
      }
    }

    // MappingObject
    //
    if (n.name () == "MappingObject" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MappingObject_type > r (
        MappingObject_traits::create (i, f, this));

      if (!this->MappingObject_)
      {
        this->MappingObject_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefBaseSystemUnitPath" && n.namespace_ ().empty ())
    {
      this->RefBaseSystemUnitPath_.set (RefBaseSystemUnitPath_traits::create (i, f, this));
      continue;
    }
  }
}

InternalElementType* InternalElementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InternalElementType (*this, f, c);
}

InternalElementType& InternalElementType::
operator= (const InternalElementType& x)
{
  if (this != &x)
  {
    static_cast< ::SystemUnitClassType& > (*this) = x;
    this->RoleRequirements_ = x.RoleRequirements_;
    this->MappingObject_ = x.MappingObject_;
    this->RefBaseSystemUnitPath_ = x.RefBaseSystemUnitPath_;
  }

  return *this;
}

InternalElementType::
~InternalElementType ()
{
}

// AttributeType
//

AttributeType::
AttributeType (const Name_type& Name)
: ::CAEXObject (Name),
  DefaultValue_ (this),
  Value_ (this),
  RefSemantic_ (this),
  Constraint_ (this),
  Attribute_ (this),
  Unit_ (this),
  AttributeDataType_ (this)
{
}

AttributeType::
AttributeType (const AttributeType& x,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  DefaultValue_ (x.DefaultValue_, f, this),
  Value_ (x.Value_, f, this),
  RefSemantic_ (x.RefSemantic_, f, this),
  Constraint_ (x.Constraint_, f, this),
  Attribute_ (x.Attribute_, f, this),
  Unit_ (x.Unit_, f, this),
  AttributeDataType_ (x.AttributeDataType_, f, this)
{
}

AttributeType::
AttributeType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  DefaultValue_ (this),
  Value_ (this),
  RefSemantic_ (this),
  Constraint_ (this),
  Attribute_ (this),
  Unit_ (this),
  AttributeDataType_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AttributeType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // DefaultValue
    //
    if (n.name () == "DefaultValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< DefaultValue_type > r (
        DefaultValue_traits::create (i, f, this));

      if (!this->DefaultValue_)
      {
        this->DefaultValue_.set (r);
        continue;
      }
    }

    // Value
    //
    if (n.name () == "Value" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Value_type > r (
        Value_traits::create (i, f, this));

      if (!this->Value_)
      {
        this->Value_.set (r);
        continue;
      }
    }

    // RefSemantic
    //
    if (n.name () == "RefSemantic" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RefSemantic_type > r (
        RefSemantic_traits::create (i, f, this));

      this->RefSemantic_.push_back (r);
      continue;
    }

    // Constraint
    //
    if (n.name () == "Constraint" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Constraint_type > r (
        Constraint_traits::create (i, f, this));

      this->Constraint_.push_back (r);
      continue;
    }

    // Attribute
    //
    if (n.name () == "Attribute" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attribute_type > r (
        Attribute_traits::create (i, f, this));

      this->Attribute_.push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Unit" && n.namespace_ ().empty ())
    {
      this->Unit_.set (Unit_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "AttributeDataType" && n.namespace_ ().empty ())
    {
      this->AttributeDataType_.set (AttributeDataType_traits::create (i, f, this));
      continue;
    }
  }
}

AttributeType* AttributeType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AttributeType (*this, f, c);
}

AttributeType& AttributeType::
operator= (const AttributeType& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->DefaultValue_ = x.DefaultValue_;
    this->Value_ = x.Value_;
    this->RefSemantic_ = x.RefSemantic_;
    this->Constraint_ = x.Constraint_;
    this->Attribute_ = x.Attribute_;
    this->Unit_ = x.Unit_;
    this->AttributeDataType_ = x.AttributeDataType_;
  }

  return *this;
}

AttributeType::
~AttributeType ()
{
}

// AttributeValueRequirementType
//

AttributeValueRequirementType::
AttributeValueRequirementType (const Name_type& Name)
: ::CAEXBasicObject (),
  OrdinalScaledType_ (this),
  NominalScaledType_ (this),
  UnknownType_ (this),
  Name_ (Name, this)
{
}

AttributeValueRequirementType::
AttributeValueRequirementType (const AttributeValueRequirementType& x,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  OrdinalScaledType_ (x.OrdinalScaledType_, f, this),
  NominalScaledType_ (x.NominalScaledType_, f, this),
  UnknownType_ (x.UnknownType_, f, this),
  Name_ (x.Name_, f, this)
{
}

AttributeValueRequirementType::
AttributeValueRequirementType (const ::xercesc::DOMElement& e,
                               ::xml_schema::flags f,
                               ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  OrdinalScaledType_ (this),
  NominalScaledType_ (this),
  UnknownType_ (this),
  Name_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AttributeValueRequirementType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // OrdinalScaledType
    //
    if (n.name () == "OrdinalScaledType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OrdinalScaledType_type > r (
        OrdinalScaledType_traits::create (i, f, this));

      if (!this->OrdinalScaledType_)
      {
        this->OrdinalScaledType_.set (r);
        continue;
      }
    }

    // NominalScaledType
    //
    if (n.name () == "NominalScaledType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NominalScaledType_type > r (
        NominalScaledType_traits::create (i, f, this));

      if (!this->NominalScaledType_)
      {
        this->NominalScaledType_.set (r);
        continue;
      }
    }

    // UnknownType
    //
    if (n.name () == "UnknownType" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< UnknownType_type > r (
        UnknownType_traits::create (i, f, this));

      if (!this->UnknownType_)
      {
        this->UnknownType_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Name" && n.namespace_ ().empty ())
    {
      this->Name_.set (Name_traits::create (i, f, this));
      continue;
    }
  }

  if (!Name_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Name",
      "");
  }
}

AttributeValueRequirementType* AttributeValueRequirementType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AttributeValueRequirementType (*this, f, c);
}

AttributeValueRequirementType& AttributeValueRequirementType::
operator= (const AttributeValueRequirementType& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->OrdinalScaledType_ = x.OrdinalScaledType_;
    this->NominalScaledType_ = x.NominalScaledType_;
    this->UnknownType_ = x.UnknownType_;
    this->Name_ = x.Name_;
  }

  return *this;
}

AttributeValueRequirementType::
~AttributeValueRequirementType ()
{
}

// MappingType
//

MappingType::
MappingType ()
: ::CAEXBasicObject (),
  AttributeNameMapping_ (this),
  InterfaceNameMapping_ (this)
{
}

MappingType::
MappingType (const MappingType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  AttributeNameMapping_ (x.AttributeNameMapping_, f, this),
  InterfaceNameMapping_ (x.InterfaceNameMapping_, f, this)
{
}

MappingType::
MappingType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  AttributeNameMapping_ (this),
  InterfaceNameMapping_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void MappingType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // AttributeNameMapping
    //
    if (n.name () == "AttributeNameMapping" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AttributeNameMapping_type > r (
        AttributeNameMapping_traits::create (i, f, this));

      this->AttributeNameMapping_.push_back (r);
      continue;
    }

    // InterfaceNameMapping
    //
    if (n.name () == "InterfaceNameMapping" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InterfaceNameMapping_type > r (
        InterfaceNameMapping_traits::create (i, f, this));

      this->InterfaceNameMapping_.push_back (r);
      continue;
    }

    break;
  }
}

MappingType* MappingType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class MappingType (*this, f, c);
}

MappingType& MappingType::
operator= (const MappingType& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->AttributeNameMapping_ = x.AttributeNameMapping_;
    this->InterfaceNameMapping_ = x.InterfaceNameMapping_;
  }

  return *this;
}

MappingType::
~MappingType ()
{
}

// Description
//

const Description::ChangeMode_type Description::ChangeMode_default_value_ (
  "state");

Description::
Description ()
: ::xml_schema::string (),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Description::
Description (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Description::
Description (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Description::
Description (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Description::
Description (const Description& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  ChangeMode_ (x.ChangeMode_, f, this)
{
}

Description::
Description (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  ChangeMode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Description::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ChangeMode" && n.namespace_ ().empty ())
    {
      this->ChangeMode_.set (ChangeMode_traits::create (i, f, this));
      continue;
    }
  }

  if (!ChangeMode_.present ())
  {
    this->ChangeMode_.set (ChangeMode_default_value ());
  }
}

Description* Description::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Description (*this, f, c);
}

Description& Description::
operator= (const Description& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->ChangeMode_ = x.ChangeMode_;
  }

  return *this;
}

Description::
~Description ()
{
}

// Version
//

const Version::ChangeMode_type Version::ChangeMode_default_value_ (
  "state");

Version::
Version ()
: ::xml_schema::string (),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Version::
Version (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Version::
Version (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Version::
Version (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Version::
Version (const Version& x,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  ChangeMode_ (x.ChangeMode_, f, this)
{
}

Version::
Version (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  ChangeMode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Version::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ChangeMode" && n.namespace_ ().empty ())
    {
      this->ChangeMode_.set (ChangeMode_traits::create (i, f, this));
      continue;
    }
  }

  if (!ChangeMode_.present ())
  {
    this->ChangeMode_.set (ChangeMode_default_value ());
  }
}

Version* Version::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Version (*this, f, c);
}

Version& Version::
operator= (const Version& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->ChangeMode_ = x.ChangeMode_;
  }

  return *this;
}

Version::
~Version ()
{
}

// Revision
//

Revision::
Revision (const RevisionDate_type& RevisionDate,
          const AuthorName_type& AuthorName)
: ::CAEXBasicObject (),
  RevisionDate_ (RevisionDate, this),
  OldVersion_ (this),
  NewVersion_ (this),
  AuthorName_ (AuthorName, this),
  Comment_ (this)
{
}

Revision::
Revision (const Revision& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  RevisionDate_ (x.RevisionDate_, f, this),
  OldVersion_ (x.OldVersion_, f, this),
  NewVersion_ (x.NewVersion_, f, this),
  AuthorName_ (x.AuthorName_, f, this),
  Comment_ (x.Comment_, f, this)
{
}

Revision::
Revision (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  RevisionDate_ (this),
  OldVersion_ (this),
  NewVersion_ (this),
  AuthorName_ (this),
  Comment_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void Revision::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RevisionDate
    //
    if (n.name () == "RevisionDate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RevisionDate_type > r (
        RevisionDate_traits::create (i, f, this));

      if (!RevisionDate_.present ())
      {
        this->RevisionDate_.set (r);
        continue;
      }
    }

    // OldVersion
    //
    if (n.name () == "OldVersion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< OldVersion_type > r (
        OldVersion_traits::create (i, f, this));

      if (!this->OldVersion_)
      {
        this->OldVersion_.set (r);
        continue;
      }
    }

    // NewVersion
    //
    if (n.name () == "NewVersion" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< NewVersion_type > r (
        NewVersion_traits::create (i, f, this));

      if (!this->NewVersion_)
      {
        this->NewVersion_.set (r);
        continue;
      }
    }

    // AuthorName
    //
    if (n.name () == "AuthorName" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< AuthorName_type > r (
        AuthorName_traits::create (i, f, this));

      if (!AuthorName_.present ())
      {
        this->AuthorName_.set (r);
        continue;
      }
    }

    // Comment
    //
    if (n.name () == "Comment" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Comment_type > r (
        Comment_traits::create (i, f, this));

      if (!this->Comment_)
      {
        this->Comment_.set (r);
        continue;
      }
    }

    break;
  }

  if (!RevisionDate_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "RevisionDate",
      "");
  }

  if (!AuthorName_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "AuthorName",
      "");
  }
}

Revision* Revision::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Revision (*this, f, c);
}

Revision& Revision::
operator= (const Revision& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->RevisionDate_ = x.RevisionDate_;
    this->OldVersion_ = x.OldVersion_;
    this->NewVersion_ = x.NewVersion_;
    this->AuthorName_ = x.AuthorName_;
    this->Comment_ = x.Comment_;
  }

  return *this;
}

Revision::
~Revision ()
{
}

// Copyright
//

const Copyright::ChangeMode_type Copyright::ChangeMode_default_value_ (
  "state");

Copyright::
Copyright ()
: ::xml_schema::string (),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Copyright::
Copyright (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Copyright::
Copyright (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Copyright::
Copyright (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base),
  ChangeMode_ (ChangeMode_default_value (), this)
{
}

Copyright::
Copyright (const Copyright& x,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (x, f, c),
  ChangeMode_ (x.ChangeMode_, f, this)
{
}

Copyright::
Copyright (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::container* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  ChangeMode_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, false, false, true);
    this->parse (p, f);
  }
}

void Copyright::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "ChangeMode" && n.namespace_ ().empty ())
    {
      this->ChangeMode_.set (ChangeMode_traits::create (i, f, this));
      continue;
    }
  }

  if (!ChangeMode_.present ())
  {
    this->ChangeMode_.set (ChangeMode_default_value ());
  }
}

Copyright* Copyright::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class Copyright (*this, f, c);
}

Copyright& Copyright::
operator= (const Copyright& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::string& > (*this) = x;
    this->ChangeMode_ = x.ChangeMode_;
  }

  return *this;
}

Copyright::
~Copyright ()
{
}

// ExternalInterface
//

ExternalInterface::
ExternalInterface (const Name_type& Name)
: ::InterfaceClassType (Name)
{
}

ExternalInterface::
ExternalInterface (const ExternalInterface& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::InterfaceClassType (x, f, c)
{
}

ExternalInterface::
ExternalInterface (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::InterfaceClassType (e, f, c)
{
}

ExternalInterface* ExternalInterface::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ExternalInterface (*this, f, c);
}

ExternalInterface::
~ExternalInterface ()
{
}

// SupportedRoleClass
//

SupportedRoleClass::
SupportedRoleClass (const RefRoleClassPath_type& RefRoleClassPath)
: ::CAEXBasicObject (),
  MappingObject_ (this),
  RefRoleClassPath_ (RefRoleClassPath, this)
{
}

SupportedRoleClass::
SupportedRoleClass (const SupportedRoleClass& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  MappingObject_ (x.MappingObject_, f, this),
  RefRoleClassPath_ (x.RefRoleClassPath_, f, this)
{
}

SupportedRoleClass::
SupportedRoleClass (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  MappingObject_ (this),
  RefRoleClassPath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SupportedRoleClass::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // MappingObject
    //
    if (n.name () == "MappingObject" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< MappingObject_type > r (
        MappingObject_traits::create (i, f, this));

      if (!this->MappingObject_)
      {
        this->MappingObject_.set (r);
        continue;
      }
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefRoleClassPath" && n.namespace_ ().empty ())
    {
      this->RefRoleClassPath_.set (RefRoleClassPath_traits::create (i, f, this));
      continue;
    }
  }

  if (!RefRoleClassPath_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "RefRoleClassPath",
      "");
  }
}

SupportedRoleClass* SupportedRoleClass::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SupportedRoleClass (*this, f, c);
}

SupportedRoleClass& SupportedRoleClass::
operator= (const SupportedRoleClass& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->MappingObject_ = x.MappingObject_;
    this->RefRoleClassPath_ = x.RefRoleClassPath_;
  }

  return *this;
}

SupportedRoleClass::
~SupportedRoleClass ()
{
}

// InternalLink
//

InternalLink::
InternalLink (const Name_type& Name)
: ::CAEXObject (Name),
  RefPartnerSideA_ (this),
  RefPartnerSideB_ (this)
{
}

InternalLink::
InternalLink (const InternalLink& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  RefPartnerSideA_ (x.RefPartnerSideA_, f, this),
  RefPartnerSideB_ (x.RefPartnerSideB_, f, this)
{
}

InternalLink::
InternalLink (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  RefPartnerSideA_ (this),
  RefPartnerSideB_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InternalLink::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefPartnerSideA" && n.namespace_ ().empty ())
    {
      this->RefPartnerSideA_.set (RefPartnerSideA_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "RefPartnerSideB" && n.namespace_ ().empty ())
    {
      this->RefPartnerSideB_.set (RefPartnerSideB_traits::create (i, f, this));
      continue;
    }
  }
}

InternalLink* InternalLink::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InternalLink (*this, f, c);
}

InternalLink& InternalLink::
operator= (const InternalLink& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->RefPartnerSideA_ = x.RefPartnerSideA_;
    this->RefPartnerSideB_ = x.RefPartnerSideB_;
  }

  return *this;
}

InternalLink::
~InternalLink ()
{
}

// RoleRequirements
//

RoleRequirements::
RoleRequirements ()
: ::CAEXBasicObject (),
  Attribute_ (this),
  ExternalInterface_ (this),
  RefBaseRoleClassPath_ (this)
{
}

RoleRequirements::
RoleRequirements (const RoleRequirements& x,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  Attribute_ (x.Attribute_, f, this),
  ExternalInterface_ (x.ExternalInterface_, f, this),
  RefBaseRoleClassPath_ (x.RefBaseRoleClassPath_, f, this)
{
}

RoleRequirements::
RoleRequirements (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f,
                  ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  Attribute_ (this),
  ExternalInterface_ (this),
  RefBaseRoleClassPath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RoleRequirements::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Attribute
    //
    if (n.name () == "Attribute" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Attribute_type > r (
        Attribute_traits::create (i, f, this));

      this->Attribute_.push_back (r);
      continue;
    }

    // ExternalInterface
    //
    if (n.name () == "ExternalInterface" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ExternalInterface_type > r (
        ExternalInterface_traits::create (i, f, this));

      this->ExternalInterface_.push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "RefBaseRoleClassPath" && n.namespace_ ().empty ())
    {
      this->RefBaseRoleClassPath_.set (RefBaseRoleClassPath_traits::create (i, f, this));
      continue;
    }
  }
}

RoleRequirements* RoleRequirements::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RoleRequirements (*this, f, c);
}

RoleRequirements& RoleRequirements::
operator= (const RoleRequirements& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->Attribute_ = x.Attribute_;
    this->ExternalInterface_ = x.ExternalInterface_;
    this->RefBaseRoleClassPath_ = x.RefBaseRoleClassPath_;
  }

  return *this;
}

RoleRequirements::
~RoleRequirements ()
{
}

// RefSemantic
//

RefSemantic::
RefSemantic (const CorrespondingAttributePath_type& CorrespondingAttributePath)
: ::CAEXBasicObject (),
  CorrespondingAttributePath_ (CorrespondingAttributePath, this)
{
}

RefSemantic::
RefSemantic (const RefSemantic& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  CorrespondingAttributePath_ (x.CorrespondingAttributePath_, f, this)
{
}

RefSemantic::
RefSemantic (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  CorrespondingAttributePath_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RefSemantic::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "CorrespondingAttributePath" && n.namespace_ ().empty ())
    {
      this->CorrespondingAttributePath_.set (CorrespondingAttributePath_traits::create (i, f, this));
      continue;
    }
  }

  if (!CorrespondingAttributePath_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "CorrespondingAttributePath",
      "");
  }
}

RefSemantic* RefSemantic::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RefSemantic (*this, f, c);
}

RefSemantic& RefSemantic::
operator= (const RefSemantic& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->CorrespondingAttributePath_ = x.CorrespondingAttributePath_;
  }

  return *this;
}

RefSemantic::
~RefSemantic ()
{
}

// AttributeDataType
//

AttributeDataType::
AttributeDataType ()
: ::xml_schema::string ()
{
}

AttributeDataType::
AttributeDataType (const char* _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

AttributeDataType::
AttributeDataType (const ::std::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

AttributeDataType::
AttributeDataType (const ::xml_schema::string& _xsd_string_base)
: ::xml_schema::string (_xsd_string_base)
{
}

AttributeDataType::
AttributeDataType (const AttributeDataType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (x, f, c)
{
}

AttributeDataType::
AttributeDataType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (e, f, c)
{
}

AttributeDataType::
AttributeDataType (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (a, f, c)
{
}

AttributeDataType::
AttributeDataType (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::string (s, e, f, c)
{
}

AttributeDataType* AttributeDataType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AttributeDataType (*this, f, c);
}

AttributeDataType::
~AttributeDataType ()
{
}

// OrdinalScaledType
//

OrdinalScaledType::
OrdinalScaledType ()
: ::xml_schema::type (),
  RequiredMaxValue_ (this),
  RequiredValue_ (this),
  RequiredMinValue_ (this)
{
}

OrdinalScaledType::
OrdinalScaledType (const OrdinalScaledType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  RequiredMaxValue_ (x.RequiredMaxValue_, f, this),
  RequiredValue_ (x.RequiredValue_, f, this),
  RequiredMinValue_ (x.RequiredMinValue_, f, this)
{
}

OrdinalScaledType::
OrdinalScaledType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  RequiredMaxValue_ (this),
  RequiredValue_ (this),
  RequiredMinValue_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void OrdinalScaledType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RequiredMaxValue
    //
    if (n.name () == "RequiredMaxValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RequiredMaxValue_type > r (
        RequiredMaxValue_traits::create (i, f, this));

      if (!this->RequiredMaxValue_)
      {
        this->RequiredMaxValue_.set (r);
        continue;
      }
    }

    // RequiredValue
    //
    if (n.name () == "RequiredValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RequiredValue_type > r (
        RequiredValue_traits::create (i, f, this));

      if (!this->RequiredValue_)
      {
        this->RequiredValue_.set (r);
        continue;
      }
    }

    // RequiredMinValue
    //
    if (n.name () == "RequiredMinValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RequiredMinValue_type > r (
        RequiredMinValue_traits::create (i, f, this));

      if (!this->RequiredMinValue_)
      {
        this->RequiredMinValue_.set (r);
        continue;
      }
    }

    break;
  }
}

OrdinalScaledType* OrdinalScaledType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class OrdinalScaledType (*this, f, c);
}

OrdinalScaledType& OrdinalScaledType::
operator= (const OrdinalScaledType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->RequiredMaxValue_ = x.RequiredMaxValue_;
    this->RequiredValue_ = x.RequiredValue_;
    this->RequiredMinValue_ = x.RequiredMinValue_;
  }

  return *this;
}

OrdinalScaledType::
~OrdinalScaledType ()
{
}

// NominalScaledType
//

NominalScaledType::
NominalScaledType ()
: ::xml_schema::type (),
  RequiredValue_ (this)
{
}

NominalScaledType::
NominalScaledType (const NominalScaledType& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  RequiredValue_ (x.RequiredValue_, f, this)
{
}

NominalScaledType::
NominalScaledType (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  RequiredValue_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void NominalScaledType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RequiredValue
    //
    if (n.name () == "RequiredValue" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RequiredValue_type > r (
        RequiredValue_traits::create (i, f, this));

      this->RequiredValue_.push_back (r);
      continue;
    }

    break;
  }
}

NominalScaledType* NominalScaledType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class NominalScaledType (*this, f, c);
}

NominalScaledType& NominalScaledType::
operator= (const NominalScaledType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->RequiredValue_ = x.RequiredValue_;
  }

  return *this;
}

NominalScaledType::
~NominalScaledType ()
{
}

// UnknownType
//

UnknownType::
UnknownType ()
: ::xml_schema::type (),
  Requirements_ (this)
{
}

UnknownType::
UnknownType (const UnknownType& x,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (x, f, c),
  Requirements_ (x.Requirements_, f, this)
{
}

UnknownType::
UnknownType (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::container* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  Requirements_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, false);
    this->parse (p, f);
  }
}

void UnknownType::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // Requirements
    //
    if (n.name () == "Requirements" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< Requirements_type > r (
        Requirements_traits::create (i, f, this));

      if (!this->Requirements_)
      {
        this->Requirements_.set (r);
        continue;
      }
    }

    break;
  }
}

UnknownType* UnknownType::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class UnknownType (*this, f, c);
}

UnknownType& UnknownType::
operator= (const UnknownType& x)
{
  if (this != &x)
  {
    static_cast< ::xml_schema::type& > (*this) = x;
    this->Requirements_ = x.Requirements_;
  }

  return *this;
}

UnknownType::
~UnknownType ()
{
}

// AttributeNameMapping
//

AttributeNameMapping::
AttributeNameMapping (const SystemUnitAttributeName_type& SystemUnitAttributeName,
                      const RoleAttributeName_type& RoleAttributeName)
: ::CAEXBasicObject (),
  SystemUnitAttributeName_ (SystemUnitAttributeName, this),
  RoleAttributeName_ (RoleAttributeName, this)
{
}

AttributeNameMapping::
AttributeNameMapping (const AttributeNameMapping& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  SystemUnitAttributeName_ (x.SystemUnitAttributeName_, f, this),
  RoleAttributeName_ (x.RoleAttributeName_, f, this)
{
}

AttributeNameMapping::
AttributeNameMapping (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  SystemUnitAttributeName_ (this),
  RoleAttributeName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void AttributeNameMapping::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "SystemUnitAttributeName" && n.namespace_ ().empty ())
    {
      this->SystemUnitAttributeName_.set (SystemUnitAttributeName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "RoleAttributeName" && n.namespace_ ().empty ())
    {
      this->RoleAttributeName_.set (RoleAttributeName_traits::create (i, f, this));
      continue;
    }
  }

  if (!SystemUnitAttributeName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "SystemUnitAttributeName",
      "");
  }

  if (!RoleAttributeName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "RoleAttributeName",
      "");
  }
}

AttributeNameMapping* AttributeNameMapping::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class AttributeNameMapping (*this, f, c);
}

AttributeNameMapping& AttributeNameMapping::
operator= (const AttributeNameMapping& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->SystemUnitAttributeName_ = x.SystemUnitAttributeName_;
    this->RoleAttributeName_ = x.RoleAttributeName_;
  }

  return *this;
}

AttributeNameMapping::
~AttributeNameMapping ()
{
}

// InterfaceNameMapping
//

InterfaceNameMapping::
InterfaceNameMapping (const SystemUnitInterfaceName_type& SystemUnitInterfaceName,
                      const RoleInterfaceName_type& RoleInterfaceName)
: ::CAEXBasicObject (),
  SystemUnitInterfaceName_ (SystemUnitInterfaceName, this),
  RoleInterfaceName_ (RoleInterfaceName, this)
{
}

InterfaceNameMapping::
InterfaceNameMapping (const InterfaceNameMapping& x,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  SystemUnitInterfaceName_ (x.SystemUnitInterfaceName_, f, this),
  RoleInterfaceName_ (x.RoleInterfaceName_, f, this)
{
}

InterfaceNameMapping::
InterfaceNameMapping (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f,
                      ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  SystemUnitInterfaceName_ (this),
  RoleInterfaceName_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InterfaceNameMapping::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "SystemUnitInterfaceName" && n.namespace_ ().empty ())
    {
      this->SystemUnitInterfaceName_.set (SystemUnitInterfaceName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "RoleInterfaceName" && n.namespace_ ().empty ())
    {
      this->RoleInterfaceName_.set (RoleInterfaceName_traits::create (i, f, this));
      continue;
    }
  }

  if (!SystemUnitInterfaceName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "SystemUnitInterfaceName",
      "");
  }

  if (!RoleInterfaceName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "RoleInterfaceName",
      "");
  }
}

InterfaceNameMapping* InterfaceNameMapping::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InterfaceNameMapping (*this, f, c);
}

InterfaceNameMapping& InterfaceNameMapping::
operator= (const InterfaceNameMapping& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->SystemUnitInterfaceName_ = x.SystemUnitInterfaceName_;
    this->RoleInterfaceName_ = x.RoleInterfaceName_;
  }

  return *this;
}

InterfaceNameMapping::
~InterfaceNameMapping ()
{
}

// CAEXFile
//

const CAEXFile::SchemaVersion_type CAEXFile::SchemaVersion_default_value_ (
  "2.15");

CAEXFile::
CAEXFile (const FileName_type& FileName)
: ::CAEXBasicObject (),
  ExternalReference_ (this),
  InstanceHierarchy_ (this),
  InterfaceClassLib_ (this),
  RoleClassLib_ (this),
  SystemUnitClassLib_ (this),
  FileName_ (FileName, this),
  SchemaVersion_ (SchemaVersion_default_value (), this)
{
}

CAEXFile::
CAEXFile (const CAEXFile& x,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  ExternalReference_ (x.ExternalReference_, f, this),
  InstanceHierarchy_ (x.InstanceHierarchy_, f, this),
  InterfaceClassLib_ (x.InterfaceClassLib_, f, this),
  RoleClassLib_ (x.RoleClassLib_, f, this),
  SystemUnitClassLib_ (x.SystemUnitClassLib_, f, this),
  FileName_ (x.FileName_, f, this),
  SchemaVersion_ (x.SchemaVersion_, f, this)
{
}

CAEXFile::
CAEXFile (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  ExternalReference_ (this),
  InstanceHierarchy_ (this),
  InterfaceClassLib_ (this),
  RoleClassLib_ (this),
  SystemUnitClassLib_ (this),
  FileName_ (this),
  SchemaVersion_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void CAEXFile::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // ExternalReference
    //
    if (n.name () == "ExternalReference" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< ExternalReference_type > r (
        ExternalReference_traits::create (i, f, this));

      this->ExternalReference_.push_back (r);
      continue;
    }

    // InstanceHierarchy
    //
    if (n.name () == "InstanceHierarchy" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InstanceHierarchy_type > r (
        InstanceHierarchy_traits::create (i, f, this));

      this->InstanceHierarchy_.push_back (r);
      continue;
    }

    // InterfaceClassLib
    //
    if (n.name () == "InterfaceClassLib" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InterfaceClassLib_type > r (
        InterfaceClassLib_traits::create (i, f, this));

      this->InterfaceClassLib_.push_back (r);
      continue;
    }

    // RoleClassLib
    //
    if (n.name () == "RoleClassLib" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RoleClassLib_type > r (
        RoleClassLib_traits::create (i, f, this));

      this->RoleClassLib_.push_back (r);
      continue;
    }

    // SystemUnitClassLib
    //
    if (n.name () == "SystemUnitClassLib" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SystemUnitClassLib_type > r (
        SystemUnitClassLib_traits::create (i, f, this));

      this->SystemUnitClassLib_.push_back (r);
      continue;
    }

    break;
  }

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "FileName" && n.namespace_ ().empty ())
    {
      this->FileName_.set (FileName_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "SchemaVersion" && n.namespace_ ().empty ())
    {
      this->SchemaVersion_.set (SchemaVersion_traits::create (i, f, this));
      continue;
    }
  }

  if (!FileName_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "FileName",
      "");
  }

  if (!SchemaVersion_.present ())
  {
    this->SchemaVersion_.set (SchemaVersion_default_value ());
  }
}

CAEXFile* CAEXFile::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class CAEXFile (*this, f, c);
}

CAEXFile& CAEXFile::
operator= (const CAEXFile& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->ExternalReference_ = x.ExternalReference_;
    this->InstanceHierarchy_ = x.InstanceHierarchy_;
    this->InterfaceClassLib_ = x.InterfaceClassLib_;
    this->RoleClassLib_ = x.RoleClassLib_;
    this->SystemUnitClassLib_ = x.SystemUnitClassLib_;
    this->FileName_ = x.FileName_;
    this->SchemaVersion_ = x.SchemaVersion_;
  }

  return *this;
}

CAEXFile::
~CAEXFile ()
{
}

// ExternalReference
//

ExternalReference::
ExternalReference (const Path_type& Path,
                   const Alias_type& Alias)
: ::CAEXBasicObject (),
  Path_ (Path, this),
  Alias_ (Alias, this)
{
}

ExternalReference::
ExternalReference (const ExternalReference& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CAEXBasicObject (x, f, c),
  Path_ (x.Path_, f, this),
  Alias_ (x.Alias_, f, this)
{
}

ExternalReference::
ExternalReference (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CAEXBasicObject (e, f | ::xml_schema::flags::base, c),
  Path_ (this),
  Alias_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void ExternalReference::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXBasicObject::parse (p, f);

  p.reset_attributes ();

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "Path" && n.namespace_ ().empty ())
    {
      this->Path_.set (Path_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "Alias" && n.namespace_ ().empty ())
    {
      this->Alias_.set (Alias_traits::create (i, f, this));
      continue;
    }
  }

  if (!Path_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Path",
      "");
  }

  if (!Alias_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "Alias",
      "");
  }
}

ExternalReference* ExternalReference::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class ExternalReference (*this, f, c);
}

ExternalReference& ExternalReference::
operator= (const ExternalReference& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXBasicObject& > (*this) = x;
    this->Path_ = x.Path_;
    this->Alias_ = x.Alias_;
  }

  return *this;
}

ExternalReference::
~ExternalReference ()
{
}

// InstanceHierarchy
//

InstanceHierarchy::
InstanceHierarchy (const Name_type& Name)
: ::CAEXObject (Name),
  InternalElement_ (this)
{
}

InstanceHierarchy::
InstanceHierarchy (const InstanceHierarchy& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  InternalElement_ (x.InternalElement_, f, this)
{
}

InstanceHierarchy::
InstanceHierarchy (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  InternalElement_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InstanceHierarchy::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // InternalElement
    //
    if (n.name () == "InternalElement" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InternalElement_type > r (
        InternalElement_traits::create (i, f, this));

      this->InternalElement_.push_back (r);
      continue;
    }

    break;
  }
}

InstanceHierarchy* InstanceHierarchy::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InstanceHierarchy (*this, f, c);
}

InstanceHierarchy& InstanceHierarchy::
operator= (const InstanceHierarchy& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->InternalElement_ = x.InternalElement_;
  }

  return *this;
}

InstanceHierarchy::
~InstanceHierarchy ()
{
}

// InterfaceClassLib
//

InterfaceClassLib::
InterfaceClassLib (const Name_type& Name)
: ::CAEXObject (Name),
  InterfaceClass_ (this)
{
}

InterfaceClassLib::
InterfaceClassLib (const InterfaceClassLib& x,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  InterfaceClass_ (x.InterfaceClass_, f, this)
{
}

InterfaceClassLib::
InterfaceClassLib (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  InterfaceClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void InterfaceClassLib::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // InterfaceClass
    //
    if (n.name () == "InterfaceClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< InterfaceClass_type > r (
        InterfaceClass_traits::create (i, f, this));

      this->InterfaceClass_.push_back (r);
      continue;
    }

    break;
  }
}

InterfaceClassLib* InterfaceClassLib::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class InterfaceClassLib (*this, f, c);
}

InterfaceClassLib& InterfaceClassLib::
operator= (const InterfaceClassLib& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->InterfaceClass_ = x.InterfaceClass_;
  }

  return *this;
}

InterfaceClassLib::
~InterfaceClassLib ()
{
}

// RoleClassLib
//

RoleClassLib::
RoleClassLib (const Name_type& Name)
: ::CAEXObject (Name),
  RoleClass_ (this)
{
}

RoleClassLib::
RoleClassLib (const RoleClassLib& x,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  RoleClass_ (x.RoleClass_, f, this)
{
}

RoleClassLib::
RoleClassLib (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  RoleClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void RoleClassLib::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // RoleClass
    //
    if (n.name () == "RoleClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< RoleClass_type > r (
        RoleClass_traits::create (i, f, this));

      this->RoleClass_.push_back (r);
      continue;
    }

    break;
  }
}

RoleClassLib* RoleClassLib::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class RoleClassLib (*this, f, c);
}

RoleClassLib& RoleClassLib::
operator= (const RoleClassLib& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->RoleClass_ = x.RoleClass_;
  }

  return *this;
}

RoleClassLib::
~RoleClassLib ()
{
}

// SystemUnitClassLib
//

SystemUnitClassLib::
SystemUnitClassLib (const Name_type& Name)
: ::CAEXObject (Name),
  SystemUnitClass_ (this)
{
}

SystemUnitClassLib::
SystemUnitClassLib (const SystemUnitClassLib& x,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::CAEXObject (x, f, c),
  SystemUnitClass_ (x.SystemUnitClass_, f, this)
{
}

SystemUnitClassLib::
SystemUnitClassLib (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f,
                    ::xml_schema::container* c)
: ::CAEXObject (e, f | ::xml_schema::flags::base, c),
  SystemUnitClass_ (this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e, true, false, true);
    this->parse (p, f);
  }
}

void SystemUnitClassLib::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  this->::CAEXObject::parse (p, f);

  for (; p.more_content (); p.next_content (false))
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // SystemUnitClass
    //
    if (n.name () == "SystemUnitClass" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< SystemUnitClass_type > r (
        SystemUnitClass_traits::create (i, f, this));

      this->SystemUnitClass_.push_back (r);
      continue;
    }

    break;
  }
}

SystemUnitClassLib* SystemUnitClassLib::
_clone (::xml_schema::flags f,
        ::xml_schema::container* c) const
{
  return new class SystemUnitClassLib (*this, f, c);
}

SystemUnitClassLib& SystemUnitClassLib::
operator= (const SystemUnitClassLib& x)
{
  if (this != &x)
  {
    static_cast< ::CAEXObject& > (*this) = x;
    this->SystemUnitClass_ = x.SystemUnitClass_;
  }

  return *this;
}

SystemUnitClassLib::
~SystemUnitClassLib ()
{
}

#include <istream>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::std::string& u,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CAEXFile > (
    ::CAEXFile_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::std::string& u,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CAEXFile > (
    ::CAEXFile_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::std::string& u,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      u, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CAEXFile > (
    ::CAEXFile_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CAEXFile_ (isrc, f, p);
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CAEXFile_ (isrc, h, f, p);
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  return ::CAEXFile_ (isrc, h, f, p);
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CAEXFile_ (isrc, f, p);
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           const ::std::string& sid,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CAEXFile_ (isrc, h, f, p);
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           const ::std::string& sid,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  return ::CAEXFile_ (isrc, h, f, p);
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xercesc::InputSource& i,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  return ::std::auto_ptr< ::CAEXFile > (
    ::CAEXFile_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xercesc::InputSource& i,
           ::xml_schema::error_handler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CAEXFile > (
    ::CAEXFile_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xercesc::InputSource& i,
           ::xercesc::DOMErrorHandler& h,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (
      i, h, p, f));

  if (!d.get ())
    throw ::xsd::cxx::tree::parsing< char > ();

  return ::std::auto_ptr< ::CAEXFile > (
    ::CAEXFile_ (
      d, f | ::xml_schema::flags::own_dom, p));
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::xercesc::DOMDocument& doc,
           ::xml_schema::flags f,
           const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
      static_cast< ::xercesc::DOMDocument* > (doc.cloneNode (true)));

    return ::std::auto_ptr< ::CAEXFile > (
      ::CAEXFile_ (
        d, f | ::xml_schema::flags::own_dom, p));
  }

  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "CAEXFile" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CAEXFile > r (
      ::xsd::cxx::tree::traits< ::CAEXFile, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CAEXFile",
    "");
}

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f,
           const ::xml_schema::properties&)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  ::xercesc::DOMDocument& doc (c.get () ? *c : *d);
  const ::xercesc::DOMElement& e (*doc.getDocumentElement ());

  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (f & ::xml_schema::flags::keep_dom)
    doc.setUserData (::xml_schema::dom::tree_node_key,
                     (c.get () ? &c : &d),
                     0);

  if (n.name () == "CAEXFile" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::CAEXFile > r (
      ::xsd::cxx::tree::traits< ::CAEXFile, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "CAEXFile",
    "");
}

#include <ostream>
#include <xsd/cxx/tree/error-handler.hxx>
#include <xsd/cxx/xml/dom/serialization-source.hxx>

void
operator<< (::xercesc::DOMElement& e, const ChangeMode& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const ChangeMode& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const ChangeMode& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const CAEXBasicObject& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Description
  //
  if (i.Description ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Description",
        e));

    s << *i.Description ();
  }

  // Version
  //
  if (i.Version ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Version",
        e));

    s << *i.Version ();
  }

  // Revision
  //
  for (CAEXBasicObject::Revision_const_iterator
       b (i.Revision ().begin ()), n (i.Revision ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Revision",
        e));

    s << *b;
  }

  // Copyright
  //
  if (i.Copyright ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Copyright",
        e));

    s << *i.Copyright ();
  }

  // AdditionalInformation
  //
  for (CAEXBasicObject::AdditionalInformation_const_iterator
       b (i.AdditionalInformation ().begin ()), n (i.AdditionalInformation ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AdditionalInformation",
        e));

    s << *b;
  }

  // ChangeMode
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ChangeMode",
        e));

    a << i.ChangeMode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CAEXObject& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // ID
  //
  if (i.ID ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ID",
        e));

    a << *i.ID ();
  }

  // Name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << i.Name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InterfaceClassType& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // Attribute
  //
  for (InterfaceClassType::Attribute_const_iterator
       b (i.Attribute ().begin ()), n (i.Attribute ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attribute",
        e));

    s << *b;
  }

  // RefBaseClassPath
  //
  if (i.RefBaseClassPath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefBaseClassPath",
        e));

    a << *i.RefBaseClassPath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InterfaceFamilyType& i)
{
  e << static_cast< const ::InterfaceClassType& > (i);

  // InterfaceClass
  //
  for (InterfaceFamilyType::InterfaceClass_const_iterator
       b (i.InterfaceClass ().begin ()), n (i.InterfaceClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InterfaceClass",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RoleClassType& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // Attribute
  //
  for (RoleClassType::Attribute_const_iterator
       b (i.Attribute ().begin ()), n (i.Attribute ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attribute",
        e));

    s << *b;
  }

  // ExternalInterface
  //
  for (RoleClassType::ExternalInterface_const_iterator
       b (i.ExternalInterface ().begin ()), n (i.ExternalInterface ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ExternalInterface",
        e));

    s << *b;
  }

  // RefBaseClassPath
  //
  if (i.RefBaseClassPath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefBaseClassPath",
        e));

    a << *i.RefBaseClassPath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RoleFamilyType& i)
{
  e << static_cast< const ::RoleClassType& > (i);

  // RoleClass
  //
  for (RoleFamilyType::RoleClass_const_iterator
       b (i.RoleClass ().begin ()), n (i.RoleClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RoleClass",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const SystemUnitClassType& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // Attribute
  //
  for (SystemUnitClassType::Attribute_const_iterator
       b (i.Attribute ().begin ()), n (i.Attribute ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attribute",
        e));

    s << *b;
  }

  // ExternalInterface
  //
  for (SystemUnitClassType::ExternalInterface_const_iterator
       b (i.ExternalInterface ().begin ()), n (i.ExternalInterface ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ExternalInterface",
        e));

    s << *b;
  }

  // InternalElement
  //
  for (SystemUnitClassType::InternalElement_const_iterator
       b (i.InternalElement ().begin ()), n (i.InternalElement ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InternalElement",
        e));

    s << *b;
  }

  // SupportedRoleClass
  //
  for (SystemUnitClassType::SupportedRoleClass_const_iterator
       b (i.SupportedRoleClass ().begin ()), n (i.SupportedRoleClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SupportedRoleClass",
        e));

    s << *b;
  }

  // InternalLink
  //
  for (SystemUnitClassType::InternalLink_const_iterator
       b (i.InternalLink ().begin ()), n (i.InternalLink ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InternalLink",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const SystemUnitFamilyType& i)
{
  e << static_cast< const ::SystemUnitClassType& > (i);

  // SystemUnitClass
  //
  for (SystemUnitFamilyType::SystemUnitClass_const_iterator
       b (i.SystemUnitClass ().begin ()), n (i.SystemUnitClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SystemUnitClass",
        e));

    s << *b;
  }

  // RefBaseClassPath
  //
  if (i.RefBaseClassPath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefBaseClassPath",
        e));

    a << *i.RefBaseClassPath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InternalElementType& i)
{
  e << static_cast< const ::SystemUnitClassType& > (i);

  // RoleRequirements
  //
  if (i.RoleRequirements ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RoleRequirements",
        e));

    s << *i.RoleRequirements ();
  }

  // MappingObject
  //
  if (i.MappingObject ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MappingObject",
        e));

    s << *i.MappingObject ();
  }

  // RefBaseSystemUnitPath
  //
  if (i.RefBaseSystemUnitPath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefBaseSystemUnitPath",
        e));

    a << *i.RefBaseSystemUnitPath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AttributeType& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // DefaultValue
  //
  if (i.DefaultValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "DefaultValue",
        e));

    s << *i.DefaultValue ();
  }

  // Value
  //
  if (i.Value ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Value",
        e));

    s << *i.Value ();
  }

  // RefSemantic
  //
  for (AttributeType::RefSemantic_const_iterator
       b (i.RefSemantic ().begin ()), n (i.RefSemantic ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RefSemantic",
        e));

    s << *b;
  }

  // Constraint
  //
  for (AttributeType::Constraint_const_iterator
       b (i.Constraint ().begin ()), n (i.Constraint ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Constraint",
        e));

    s << *b;
  }

  // Attribute
  //
  for (AttributeType::Attribute_const_iterator
       b (i.Attribute ().begin ()), n (i.Attribute ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attribute",
        e));

    s << *b;
  }

  // Unit
  //
  if (i.Unit ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Unit",
        e));

    a << *i.Unit ();
  }

  // AttributeDataType
  //
  if (i.AttributeDataType ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "AttributeDataType",
        e));

    a << *i.AttributeDataType ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AttributeValueRequirementType& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // OrdinalScaledType
  //
  if (i.OrdinalScaledType ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OrdinalScaledType",
        e));

    s << *i.OrdinalScaledType ();
  }

  // NominalScaledType
  //
  if (i.NominalScaledType ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NominalScaledType",
        e));

    s << *i.NominalScaledType ();
  }

  // UnknownType
  //
  if (i.UnknownType ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "UnknownType",
        e));

    s << *i.UnknownType ();
  }

  // Name
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Name",
        e));

    a << i.Name ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const MappingType& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // AttributeNameMapping
  //
  for (MappingType::AttributeNameMapping_const_iterator
       b (i.AttributeNameMapping ().begin ()), n (i.AttributeNameMapping ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AttributeNameMapping",
        e));

    s << *b;
  }

  // InterfaceNameMapping
  //
  for (MappingType::InterfaceNameMapping_const_iterator
       b (i.InterfaceNameMapping ().begin ()), n (i.InterfaceNameMapping ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InterfaceNameMapping",
        e));

    s << *b;
  }
}

void
CAEXFile_ (::std::ostream& o,
           const ::CAEXFile& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CAEXFile_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CAEXFile_ (::std::ostream& o,
           const ::CAEXFile& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0);

  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CAEXFile_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CAEXFile_ (::std::ostream& o,
           const ::CAEXFile& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CAEXFile_ (s, m, f));
  ::xsd::cxx::xml::dom::ostream_format_target t (o);
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CAEXFile_ (::xercesc::XMLFormatTarget& t,
           const ::CAEXFile& s,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CAEXFile_ (s, m, f));

  ::xsd::cxx::tree::error_handler< char > h;

  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    h.throw_if_failed< ::xsd::cxx::tree::serialization< char > > ();
  }
}

void
CAEXFile_ (::xercesc::XMLFormatTarget& t,
           const ::CAEXFile& s,
           ::xml_schema::error_handler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CAEXFile_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CAEXFile_ (::xercesc::XMLFormatTarget& t,
           const ::CAEXFile& s,
           ::xercesc::DOMErrorHandler& h,
           const ::xml_schema::namespace_infomap& m,
           const ::std::string& e,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::CAEXFile_ (s, m, f));
  if (!::xsd::cxx::xml::dom::serialize (t, *d, e, h, f))
  {
    throw ::xsd::cxx::tree::serialization< char > ();
  }
}

void
CAEXFile_ (::xercesc::DOMDocument& d,
           const ::CAEXFile& s,
           ::xml_schema::flags)
{
  ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "CAEXFile" &&
      n.namespace_ () == "")
  {
    e << s;
  }
  else
  {
    throw ::xsd::cxx::tree::unexpected_element < char > (
      n.name (),
      n.namespace_ (),
      "CAEXFile",
      "");
  }
}

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CAEXFile_ (const ::CAEXFile& s,
           const ::xml_schema::namespace_infomap& m,
           ::xml_schema::flags f)
{
  ::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::serialize< char > (
      "CAEXFile",
      "",
      m, f));

  ::CAEXFile_ (*d, s, f);
  return d;
}

void
operator<< (::xercesc::DOMElement& e, const Description& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // ChangeMode
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ChangeMode",
        e));

    a << i.ChangeMode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Version& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // ChangeMode
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ChangeMode",
        e));

    a << i.ChangeMode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Revision& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // RevisionDate
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RevisionDate",
        e));

    s << i.RevisionDate ();
  }

  // OldVersion
  //
  if (i.OldVersion ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "OldVersion",
        e));

    s << *i.OldVersion ();
  }

  // NewVersion
  //
  if (i.NewVersion ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "NewVersion",
        e));

    s << *i.NewVersion ();
  }

  // AuthorName
  //
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "AuthorName",
        e));

    s << i.AuthorName ();
  }

  // Comment
  //
  if (i.Comment ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Comment",
        e));

    s << *i.Comment ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const Copyright& i)
{
  e << static_cast< const ::xml_schema::string& > (i);

  // ChangeMode
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "ChangeMode",
        e));

    a << i.ChangeMode ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ExternalInterface& i)
{
  e << static_cast< const ::InterfaceClassType& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const SupportedRoleClass& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // MappingObject
  //
  if (i.MappingObject ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "MappingObject",
        e));

    s << *i.MappingObject ();
  }

  // RefRoleClassPath
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefRoleClassPath",
        e));

    a << i.RefRoleClassPath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InternalLink& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // RefPartnerSideA
  //
  if (i.RefPartnerSideA ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefPartnerSideA",
        e));

    a << *i.RefPartnerSideA ();
  }

  // RefPartnerSideB
  //
  if (i.RefPartnerSideB ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefPartnerSideB",
        e));

    a << *i.RefPartnerSideB ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RoleRequirements& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // Attribute
  //
  for (RoleRequirements::Attribute_const_iterator
       b (i.Attribute ().begin ()), n (i.Attribute ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Attribute",
        e));

    s << *b;
  }

  // ExternalInterface
  //
  for (RoleRequirements::ExternalInterface_const_iterator
       b (i.ExternalInterface ().begin ()), n (i.ExternalInterface ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ExternalInterface",
        e));

    s << *b;
  }

  // RefBaseRoleClassPath
  //
  if (i.RefBaseRoleClassPath ())
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RefBaseRoleClassPath",
        e));

    a << *i.RefBaseRoleClassPath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const RefSemantic& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // CorrespondingAttributePath
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "CorrespondingAttributePath",
        e));

    a << i.CorrespondingAttributePath ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AttributeDataType& i)
{
  e << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMAttr& a, const AttributeDataType& i)
{
  a << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xml_schema::list_stream& l,
            const AttributeDataType& i)
{
  l << static_cast< const ::xml_schema::string& > (i);
}

void
operator<< (::xercesc::DOMElement& e, const OrdinalScaledType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // RequiredMaxValue
  //
  if (i.RequiredMaxValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RequiredMaxValue",
        e));

    s << *i.RequiredMaxValue ();
  }

  // RequiredValue
  //
  if (i.RequiredValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RequiredValue",
        e));

    s << *i.RequiredValue ();
  }

  // RequiredMinValue
  //
  if (i.RequiredMinValue ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RequiredMinValue",
        e));

    s << *i.RequiredMinValue ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const NominalScaledType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // RequiredValue
  //
  for (NominalScaledType::RequiredValue_const_iterator
       b (i.RequiredValue ().begin ()), n (i.RequiredValue ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RequiredValue",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const UnknownType& i)
{
  e << static_cast< const ::xml_schema::type& > (i);

  // Requirements
  //
  if (i.Requirements ())
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "Requirements",
        e));

    s << *i.Requirements ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const AttributeNameMapping& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // SystemUnitAttributeName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SystemUnitAttributeName",
        e));

    a << i.SystemUnitAttributeName ();
  }

  // RoleAttributeName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RoleAttributeName",
        e));

    a << i.RoleAttributeName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InterfaceNameMapping& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // SystemUnitInterfaceName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SystemUnitInterfaceName",
        e));

    a << i.SystemUnitInterfaceName ();
  }

  // RoleInterfaceName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "RoleInterfaceName",
        e));

    a << i.RoleInterfaceName ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const CAEXFile& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // ExternalReference
  //
  for (CAEXFile::ExternalReference_const_iterator
       b (i.ExternalReference ().begin ()), n (i.ExternalReference ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "ExternalReference",
        e));

    s << *b;
  }

  // InstanceHierarchy
  //
  for (CAEXFile::InstanceHierarchy_const_iterator
       b (i.InstanceHierarchy ().begin ()), n (i.InstanceHierarchy ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InstanceHierarchy",
        e));

    s << *b;
  }

  // InterfaceClassLib
  //
  for (CAEXFile::InterfaceClassLib_const_iterator
       b (i.InterfaceClassLib ().begin ()), n (i.InterfaceClassLib ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InterfaceClassLib",
        e));

    s << *b;
  }

  // RoleClassLib
  //
  for (CAEXFile::RoleClassLib_const_iterator
       b (i.RoleClassLib ().begin ()), n (i.RoleClassLib ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RoleClassLib",
        e));

    s << *b;
  }

  // SystemUnitClassLib
  //
  for (CAEXFile::SystemUnitClassLib_const_iterator
       b (i.SystemUnitClassLib ().begin ()), n (i.SystemUnitClassLib ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SystemUnitClassLib",
        e));

    s << *b;
  }

  // FileName
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "FileName",
        e));

    a << i.FileName ();
  }

  // SchemaVersion
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "SchemaVersion",
        e));

    a << i.SchemaVersion ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const ExternalReference& i)
{
  e << static_cast< const ::CAEXBasicObject& > (i);

  // Path
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Path",
        e));

    a << i.Path ();
  }

  // Alias
  //
  {
    ::xercesc::DOMAttr& a (
      ::xsd::cxx::xml::dom::create_attribute (
        "Alias",
        e));

    a << i.Alias ();
  }
}

void
operator<< (::xercesc::DOMElement& e, const InstanceHierarchy& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // InternalElement
  //
  for (InstanceHierarchy::InternalElement_const_iterator
       b (i.InternalElement ().begin ()), n (i.InternalElement ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InternalElement",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const InterfaceClassLib& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // InterfaceClass
  //
  for (InterfaceClassLib::InterfaceClass_const_iterator
       b (i.InterfaceClass ().begin ()), n (i.InterfaceClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "InterfaceClass",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const RoleClassLib& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // RoleClass
  //
  for (RoleClassLib::RoleClass_const_iterator
       b (i.RoleClass ().begin ()), n (i.RoleClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "RoleClass",
        e));

    s << *b;
  }
}

void
operator<< (::xercesc::DOMElement& e, const SystemUnitClassLib& i)
{
  e << static_cast< const ::CAEXObject& > (i);

  // SystemUnitClass
  //
  for (SystemUnitClassLib::SystemUnitClass_const_iterator
       b (i.SystemUnitClass ().begin ()), n (i.SystemUnitClass ().end ());
       b != n; ++b)
  {
    ::xercesc::DOMElement& s (
      ::xsd::cxx::xml::dom::create_element (
        "SystemUnitClass",
        e));

    s << *b;
  }
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

