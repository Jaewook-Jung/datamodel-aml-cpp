// Copyright (c) 2005-2014 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

#ifndef CAEX_CLASSMODEL_V2_15_HXX
#define CAEX_CLASSMODEL_V2_15_HXX

#ifndef XSD_USE_CHAR
#define XSD_USE_CHAR
#endif

#ifndef XSD_CXX_TREE_USE_CHAR
#define XSD_CXX_TREE_USE_CHAR
#endif

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/config.hxx>

#if (XSD_INT_VERSION != 4000000L)
#error XSD runtime version mismatch
#endif

#include <xsd/cxx/pre.hxx>

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/types.hxx>

#include <xsd/cxx/xml/error-handler.hxx>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

#include <xsd/cxx/tree/parsing.hxx>
#include <xsd/cxx/tree/parsing/byte.hxx>
#include <xsd/cxx/tree/parsing/unsigned-byte.hxx>
#include <xsd/cxx/tree/parsing/short.hxx>
#include <xsd/cxx/tree/parsing/unsigned-short.hxx>
#include <xsd/cxx/tree/parsing/int.hxx>
#include <xsd/cxx/tree/parsing/unsigned-int.hxx>
#include <xsd/cxx/tree/parsing/long.hxx>
#include <xsd/cxx/tree/parsing/unsigned-long.hxx>
#include <xsd/cxx/tree/parsing/boolean.hxx>
#include <xsd/cxx/tree/parsing/float.hxx>
#include <xsd/cxx/tree/parsing/double.hxx>
#include <xsd/cxx/tree/parsing/decimal.hxx>

#include <xsd/cxx/xml/dom/serialization-header.hxx>
#include <xsd/cxx/tree/serialization.hxx>
#include <xsd/cxx/tree/serialization/byte.hxx>
#include <xsd/cxx/tree/serialization/unsigned-byte.hxx>
#include <xsd/cxx/tree/serialization/short.hxx>
#include <xsd/cxx/tree/serialization/unsigned-short.hxx>
#include <xsd/cxx/tree/serialization/int.hxx>
#include <xsd/cxx/tree/serialization/unsigned-int.hxx>
#include <xsd/cxx/tree/serialization/long.hxx>
#include <xsd/cxx/tree/serialization/unsigned-long.hxx>
#include <xsd/cxx/tree/serialization/boolean.hxx>
#include <xsd/cxx/tree/serialization/float.hxx>
#include <xsd/cxx/tree/serialization/double.hxx>
#include <xsd/cxx/tree/serialization/decimal.hxx>

namespace xml_schema
{
  // anyType and anySimpleType.
  //
  typedef ::xsd::cxx::tree::type type;
  typedef ::xsd::cxx::tree::simple_type< char, type > simple_type;
  typedef ::xsd::cxx::tree::type container;

  // 8-bit
  //
  typedef signed char byte;
  typedef unsigned char unsigned_byte;

  // 16-bit
  //
  typedef short short_;
  typedef unsigned short unsigned_short;

  // 32-bit
  //
  typedef int int_;
  typedef unsigned int unsigned_int;

  // 64-bit
  //
  typedef long long long_;
  typedef unsigned long long unsigned_long;

  // Supposed to be arbitrary-length integral types.
  //
  typedef long long integer;
  typedef long long non_positive_integer;
  typedef unsigned long long non_negative_integer;
  typedef unsigned long long positive_integer;
  typedef long long negative_integer;

  // Boolean.
  //
  typedef bool boolean;

  // Floating-point types.
  //
  typedef float float_;
  typedef double double_;
  typedef double decimal;

  // String types.
  //
  typedef ::xsd::cxx::tree::string< char, simple_type > string;
  typedef ::xsd::cxx::tree::normalized_string< char, string > normalized_string;
  typedef ::xsd::cxx::tree::token< char, normalized_string > token;
  typedef ::xsd::cxx::tree::name< char, token > name;
  typedef ::xsd::cxx::tree::nmtoken< char, token > nmtoken;
  typedef ::xsd::cxx::tree::nmtokens< char, simple_type, nmtoken > nmtokens;
  typedef ::xsd::cxx::tree::ncname< char, name > ncname;
  typedef ::xsd::cxx::tree::language< char, token > language;

  // ID/IDREF.
  //
  typedef ::xsd::cxx::tree::id< char, ncname > id;
  typedef ::xsd::cxx::tree::idref< char, ncname, type > idref;
  typedef ::xsd::cxx::tree::idrefs< char, simple_type, idref > idrefs;

  // URI.
  //
  typedef ::xsd::cxx::tree::uri< char, simple_type > uri;

  // Qualified name.
  //
  typedef ::xsd::cxx::tree::qname< char, simple_type, uri, ncname > qname;

  // Binary.
  //
  typedef ::xsd::cxx::tree::buffer< char > buffer;
  typedef ::xsd::cxx::tree::base64_binary< char, simple_type > base64_binary;
  typedef ::xsd::cxx::tree::hex_binary< char, simple_type > hex_binary;

  // Date/time.
  //
  typedef ::xsd::cxx::tree::time_zone time_zone;
  typedef ::xsd::cxx::tree::date< char, simple_type > date;
  typedef ::xsd::cxx::tree::date_time< char, simple_type > date_time;
  typedef ::xsd::cxx::tree::duration< char, simple_type > duration;
  typedef ::xsd::cxx::tree::gday< char, simple_type > gday;
  typedef ::xsd::cxx::tree::gmonth< char, simple_type > gmonth;
  typedef ::xsd::cxx::tree::gmonth_day< char, simple_type > gmonth_day;
  typedef ::xsd::cxx::tree::gyear< char, simple_type > gyear;
  typedef ::xsd::cxx::tree::gyear_month< char, simple_type > gyear_month;
  typedef ::xsd::cxx::tree::time< char, simple_type > time;

  // Entity.
  //
  typedef ::xsd::cxx::tree::entity< char, ncname > entity;
  typedef ::xsd::cxx::tree::entities< char, simple_type, entity > entities;

  typedef ::xsd::cxx::tree::content_order content_order;
  // Namespace information and list stream. Used in
  // serialization functions.
  //
  typedef ::xsd::cxx::xml::dom::namespace_info< char > namespace_info;
  typedef ::xsd::cxx::xml::dom::namespace_infomap< char > namespace_infomap;
  typedef ::xsd::cxx::tree::list_stream< char > list_stream;
  typedef ::xsd::cxx::tree::as_double< double_ > as_double;
  typedef ::xsd::cxx::tree::as_decimal< decimal > as_decimal;
  typedef ::xsd::cxx::tree::facet facet;

  // Flags and properties.
  //
  typedef ::xsd::cxx::tree::flags flags;
  typedef ::xsd::cxx::tree::properties< char > properties;

  // Parsing/serialization diagnostics.
  //
  typedef ::xsd::cxx::tree::severity severity;
  typedef ::xsd::cxx::tree::error< char > error;
  typedef ::xsd::cxx::tree::diagnostics< char > diagnostics;

  // Exceptions.
  //
  typedef ::xsd::cxx::tree::exception< char > exception;
  typedef ::xsd::cxx::tree::bounds< char > bounds;
  typedef ::xsd::cxx::tree::duplicate_id< char > duplicate_id;
  typedef ::xsd::cxx::tree::parsing< char > parsing;
  typedef ::xsd::cxx::tree::expected_element< char > expected_element;
  typedef ::xsd::cxx::tree::unexpected_element< char > unexpected_element;
  typedef ::xsd::cxx::tree::expected_attribute< char > expected_attribute;
  typedef ::xsd::cxx::tree::unexpected_enumerator< char > unexpected_enumerator;
  typedef ::xsd::cxx::tree::expected_text_content< char > expected_text_content;
  typedef ::xsd::cxx::tree::no_prefix_mapping< char > no_prefix_mapping;
  typedef ::xsd::cxx::tree::serialization< char > serialization;

  // Error handler callback interface.
  //
  typedef ::xsd::cxx::xml::error_handler< char > error_handler;

  // DOM interaction.
  //
  namespace dom
  {
    // Automatic pointer for DOMDocument.
    //
    using ::xsd::cxx::xml::dom::auto_ptr;

#ifndef XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
#define XSD_CXX_TREE_TREE_NODE_KEY__XML_SCHEMA
    // DOM user data key for back pointers to tree nodes.
    //
    const XMLCh* const tree_node_key = ::xsd::cxx::tree::user_data_keys::node;
#endif
  }
}

// Forward declarations.
//
class ChangeMode;
class CAEXBasicObject;
class CAEXObject;
class InterfaceClassType;
class InterfaceFamilyType;
class RoleClassType;
class RoleFamilyType;
class SystemUnitClassType;
class SystemUnitFamilyType;
class InternalElementType;
class AttributeType;
class AttributeValueRequirementType;
class MappingType;
class Description;
class Version;
class Revision;
class Copyright;
class ExternalInterface;
class SupportedRoleClass;
class InternalLink;
class RoleRequirements;
class RefSemantic;
class AttributeDataType;
class OrdinalScaledType;
class NominalScaledType;
class UnknownType;
class AttributeNameMapping;
class InterfaceNameMapping;
class CAEXFile;
class ExternalReference;
class InstanceHierarchy;
class InterfaceClassLib;
class RoleClassLib;
class SystemUnitClassLib;

#include <memory>    // ::std::auto_ptr
#include <limits>    // std::numeric_limits
#include <algorithm> // std::binary_search

#include <xsd/cxx/xml/char-utf8.hxx>

#include <xsd/cxx/tree/exceptions.hxx>
#include <xsd/cxx/tree/elements.hxx>
#include <xsd/cxx/tree/containers.hxx>
#include <xsd/cxx/tree/list.hxx>

#include <xsd/cxx/xml/dom/parsing-header.hxx>

class ChangeMode: public ::xml_schema::string
{
  public:
  enum value
  {
    state,
    create,
    delete_,
    change
  };

  ChangeMode (value v);

  ChangeMode (const char* v);

  ChangeMode (const ::std::string& v);

  ChangeMode (const ::xml_schema::string& v);

  ChangeMode (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  ChangeMode (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  ChangeMode (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  ChangeMode (const ChangeMode& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual ChangeMode*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ChangeMode&
  operator= (value v);

  virtual
  operator value () const
  {
    return _xsd_ChangeMode_convert ();
  }

  protected:
  value
  _xsd_ChangeMode_convert () const;

  public:
  static const char* const _xsd_ChangeMode_literals_[4];
  static const value _xsd_ChangeMode_indexes_[4];
};

class CAEXBasicObject: public ::xml_schema::type
{
  public:
  // Description
  //
  typedef ::Description Description_type;
  typedef ::xsd::cxx::tree::optional< Description_type > Description_optional;
  typedef ::xsd::cxx::tree::traits< Description_type, char > Description_traits;

  const Description_optional&
  Description () const;

  Description_optional&
  Description ();

  void
  Description (const Description_type& x);

  void
  Description (const Description_optional& x);

  void
  Description (::std::auto_ptr< Description_type > p);

  // Version
  //
  typedef ::Version Version_type;
  typedef ::xsd::cxx::tree::optional< Version_type > Version_optional;
  typedef ::xsd::cxx::tree::traits< Version_type, char > Version_traits;

  const Version_optional&
  Version () const;

  Version_optional&
  Version ();

  void
  Version (const Version_type& x);

  void
  Version (const Version_optional& x);

  void
  Version (::std::auto_ptr< Version_type > p);

  // Revision
  //
  typedef ::Revision Revision_type;
  typedef ::xsd::cxx::tree::sequence< Revision_type > Revision_sequence;
  typedef Revision_sequence::iterator Revision_iterator;
  typedef Revision_sequence::const_iterator Revision_const_iterator;
  typedef ::xsd::cxx::tree::traits< Revision_type, char > Revision_traits;

  const Revision_sequence&
  Revision () const;

  Revision_sequence&
  Revision ();

  void
  Revision (const Revision_sequence& s);

  // Copyright
  //
  typedef ::Copyright Copyright_type;
  typedef ::xsd::cxx::tree::optional< Copyright_type > Copyright_optional;
  typedef ::xsd::cxx::tree::traits< Copyright_type, char > Copyright_traits;

  const Copyright_optional&
  Copyright () const;

  Copyright_optional&
  Copyright ();

  void
  Copyright (const Copyright_type& x);

  void
  Copyright (const Copyright_optional& x);

  void
  Copyright (::std::auto_ptr< Copyright_type > p);

  // AdditionalInformation
  //
  typedef ::xml_schema::type AdditionalInformation_type;
  typedef ::xsd::cxx::tree::sequence< AdditionalInformation_type > AdditionalInformation_sequence;
  typedef AdditionalInformation_sequence::iterator AdditionalInformation_iterator;
  typedef AdditionalInformation_sequence::const_iterator AdditionalInformation_const_iterator;
  typedef ::xsd::cxx::tree::traits< AdditionalInformation_type, char > AdditionalInformation_traits;

  const AdditionalInformation_sequence&
  AdditionalInformation () const;

  AdditionalInformation_sequence&
  AdditionalInformation ();

  void
  AdditionalInformation (const AdditionalInformation_sequence& s);

  // ChangeMode
  //
  typedef ::ChangeMode ChangeMode_type;
  typedef ::xsd::cxx::tree::traits< ChangeMode_type, char > ChangeMode_traits;

  const ChangeMode_type&
  ChangeMode () const;

  ChangeMode_type&
  ChangeMode ();

  void
  ChangeMode (const ChangeMode_type& x);

  void
  ChangeMode (::std::auto_ptr< ChangeMode_type > p);

  static const ChangeMode_type&
  ChangeMode_default_value ();

  // Constructors.
  //
  CAEXBasicObject ();

  CAEXBasicObject (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  CAEXBasicObject (const CAEXBasicObject& x,
                   ::xml_schema::flags f = 0,
                   ::xml_schema::container* c = 0);

  virtual CAEXBasicObject*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CAEXBasicObject&
  operator= (const CAEXBasicObject& x);

  virtual 
  ~CAEXBasicObject ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Description_optional Description_;
  Version_optional Version_;
  Revision_sequence Revision_;
  Copyright_optional Copyright_;
  AdditionalInformation_sequence AdditionalInformation_;
  ::xsd::cxx::tree::one< ChangeMode_type > ChangeMode_;
  static const ChangeMode_type ChangeMode_default_value_;
};

class CAEXObject: public ::CAEXBasicObject
{
  public:
  // ID
  //
  typedef ::xml_schema::string ID_type;
  typedef ::xsd::cxx::tree::optional< ID_type > ID_optional;
  typedef ::xsd::cxx::tree::traits< ID_type, char > ID_traits;

  const ID_optional&
  ID () const;

  ID_optional&
  ID ();

  void
  ID (const ID_type& x);

  void
  ID (const ID_optional& x);

  void
  ID (::std::auto_ptr< ID_type > p);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Constructors.
  //
  CAEXObject (const Name_type&);

  CAEXObject (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  CAEXObject (const CAEXObject& x,
              ::xml_schema::flags f = 0,
              ::xml_schema::container* c = 0);

  virtual CAEXObject*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CAEXObject&
  operator= (const CAEXObject& x);

  virtual 
  ~CAEXObject ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ID_optional ID_;
  ::xsd::cxx::tree::one< Name_type > Name_;
};

class InterfaceClassType: public ::CAEXObject
{
  public:
  // Attribute
  //
  typedef ::AttributeType Attribute_type;
  typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
  typedef Attribute_sequence::iterator Attribute_iterator;
  typedef Attribute_sequence::const_iterator Attribute_const_iterator;
  typedef ::xsd::cxx::tree::traits< Attribute_type, char > Attribute_traits;

  const Attribute_sequence&
  Attribute () const;

  Attribute_sequence&
  Attribute ();

  void
  Attribute (const Attribute_sequence& s);

  // RefBaseClassPath
  //
  typedef ::xml_schema::string RefBaseClassPath_type;
  typedef ::xsd::cxx::tree::optional< RefBaseClassPath_type > RefBaseClassPath_optional;
  typedef ::xsd::cxx::tree::traits< RefBaseClassPath_type, char > RefBaseClassPath_traits;

  const RefBaseClassPath_optional&
  RefBaseClassPath () const;

  RefBaseClassPath_optional&
  RefBaseClassPath ();

  void
  RefBaseClassPath (const RefBaseClassPath_type& x);

  void
  RefBaseClassPath (const RefBaseClassPath_optional& x);

  void
  RefBaseClassPath (::std::auto_ptr< RefBaseClassPath_type > p);

  // Constructors.
  //
  InterfaceClassType (const Name_type&);

  InterfaceClassType (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  InterfaceClassType (const InterfaceClassType& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual InterfaceClassType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InterfaceClassType&
  operator= (const InterfaceClassType& x);

  virtual 
  ~InterfaceClassType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Attribute_sequence Attribute_;
  RefBaseClassPath_optional RefBaseClassPath_;
};

class InterfaceFamilyType: public ::InterfaceClassType
{
  public:
  // InterfaceClass
  //
  typedef ::InterfaceFamilyType InterfaceClass_type;
  typedef ::xsd::cxx::tree::sequence< InterfaceClass_type > InterfaceClass_sequence;
  typedef InterfaceClass_sequence::iterator InterfaceClass_iterator;
  typedef InterfaceClass_sequence::const_iterator InterfaceClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< InterfaceClass_type, char > InterfaceClass_traits;

  const InterfaceClass_sequence&
  InterfaceClass () const;

  InterfaceClass_sequence&
  InterfaceClass ();

  void
  InterfaceClass (const InterfaceClass_sequence& s);

  // Constructors.
  //
  InterfaceFamilyType (const Name_type&);

  InterfaceFamilyType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  InterfaceFamilyType (const InterfaceFamilyType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual InterfaceFamilyType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InterfaceFamilyType&
  operator= (const InterfaceFamilyType& x);

  virtual 
  ~InterfaceFamilyType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  InterfaceClass_sequence InterfaceClass_;
};

class RoleClassType: public ::CAEXObject
{
  public:
  // Attribute
  //
  typedef ::AttributeType Attribute_type;
  typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
  typedef Attribute_sequence::iterator Attribute_iterator;
  typedef Attribute_sequence::const_iterator Attribute_const_iterator;
  typedef ::xsd::cxx::tree::traits< Attribute_type, char > Attribute_traits;

  const Attribute_sequence&
  Attribute () const;

  Attribute_sequence&
  Attribute ();

  void
  Attribute (const Attribute_sequence& s);

  // ExternalInterface
  //
  typedef ::ExternalInterface ExternalInterface_type;
  typedef ::xsd::cxx::tree::sequence< ExternalInterface_type > ExternalInterface_sequence;
  typedef ExternalInterface_sequence::iterator ExternalInterface_iterator;
  typedef ExternalInterface_sequence::const_iterator ExternalInterface_const_iterator;
  typedef ::xsd::cxx::tree::traits< ExternalInterface_type, char > ExternalInterface_traits;

  const ExternalInterface_sequence&
  ExternalInterface () const;

  ExternalInterface_sequence&
  ExternalInterface ();

  void
  ExternalInterface (const ExternalInterface_sequence& s);

  // RefBaseClassPath
  //
  typedef ::xml_schema::string RefBaseClassPath_type;
  typedef ::xsd::cxx::tree::optional< RefBaseClassPath_type > RefBaseClassPath_optional;
  typedef ::xsd::cxx::tree::traits< RefBaseClassPath_type, char > RefBaseClassPath_traits;

  const RefBaseClassPath_optional&
  RefBaseClassPath () const;

  RefBaseClassPath_optional&
  RefBaseClassPath ();

  void
  RefBaseClassPath (const RefBaseClassPath_type& x);

  void
  RefBaseClassPath (const RefBaseClassPath_optional& x);

  void
  RefBaseClassPath (::std::auto_ptr< RefBaseClassPath_type > p);

  // Constructors.
  //
  RoleClassType (const Name_type&);

  RoleClassType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  RoleClassType (const RoleClassType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual RoleClassType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RoleClassType&
  operator= (const RoleClassType& x);

  virtual 
  ~RoleClassType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Attribute_sequence Attribute_;
  ExternalInterface_sequence ExternalInterface_;
  RefBaseClassPath_optional RefBaseClassPath_;
};

class RoleFamilyType: public ::RoleClassType
{
  public:
  // RoleClass
  //
  typedef ::RoleFamilyType RoleClass_type;
  typedef ::xsd::cxx::tree::sequence< RoleClass_type > RoleClass_sequence;
  typedef RoleClass_sequence::iterator RoleClass_iterator;
  typedef RoleClass_sequence::const_iterator RoleClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< RoleClass_type, char > RoleClass_traits;

  const RoleClass_sequence&
  RoleClass () const;

  RoleClass_sequence&
  RoleClass ();

  void
  RoleClass (const RoleClass_sequence& s);

  // Constructors.
  //
  RoleFamilyType (const Name_type&);

  RoleFamilyType (const ::xercesc::DOMElement& e,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  RoleFamilyType (const RoleFamilyType& x,
                  ::xml_schema::flags f = 0,
                  ::xml_schema::container* c = 0);

  virtual RoleFamilyType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RoleFamilyType&
  operator= (const RoleFamilyType& x);

  virtual 
  ~RoleFamilyType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  RoleClass_sequence RoleClass_;
};

class SystemUnitClassType: public ::CAEXObject
{
  public:
  // Attribute
  //
  typedef ::AttributeType Attribute_type;
  typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
  typedef Attribute_sequence::iterator Attribute_iterator;
  typedef Attribute_sequence::const_iterator Attribute_const_iterator;
  typedef ::xsd::cxx::tree::traits< Attribute_type, char > Attribute_traits;

  const Attribute_sequence&
  Attribute () const;

  Attribute_sequence&
  Attribute ();

  void
  Attribute (const Attribute_sequence& s);

  // ExternalInterface
  //
  typedef ::InterfaceClassType ExternalInterface_type;
  typedef ::xsd::cxx::tree::sequence< ExternalInterface_type > ExternalInterface_sequence;
  typedef ExternalInterface_sequence::iterator ExternalInterface_iterator;
  typedef ExternalInterface_sequence::const_iterator ExternalInterface_const_iterator;
  typedef ::xsd::cxx::tree::traits< ExternalInterface_type, char > ExternalInterface_traits;

  const ExternalInterface_sequence&
  ExternalInterface () const;

  ExternalInterface_sequence&
  ExternalInterface ();

  void
  ExternalInterface (const ExternalInterface_sequence& s);

  // InternalElement
  //
  typedef ::InternalElementType InternalElement_type;
  typedef ::xsd::cxx::tree::sequence< InternalElement_type > InternalElement_sequence;
  typedef InternalElement_sequence::iterator InternalElement_iterator;
  typedef InternalElement_sequence::const_iterator InternalElement_const_iterator;
  typedef ::xsd::cxx::tree::traits< InternalElement_type, char > InternalElement_traits;

  const InternalElement_sequence&
  InternalElement () const;

  InternalElement_sequence&
  InternalElement ();

  void
  InternalElement (const InternalElement_sequence& s);

  // SupportedRoleClass
  //
  typedef ::SupportedRoleClass SupportedRoleClass_type;
  typedef ::xsd::cxx::tree::sequence< SupportedRoleClass_type > SupportedRoleClass_sequence;
  typedef SupportedRoleClass_sequence::iterator SupportedRoleClass_iterator;
  typedef SupportedRoleClass_sequence::const_iterator SupportedRoleClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< SupportedRoleClass_type, char > SupportedRoleClass_traits;

  const SupportedRoleClass_sequence&
  SupportedRoleClass () const;

  SupportedRoleClass_sequence&
  SupportedRoleClass ();

  void
  SupportedRoleClass (const SupportedRoleClass_sequence& s);

  // InternalLink
  //
  typedef ::InternalLink InternalLink_type;
  typedef ::xsd::cxx::tree::sequence< InternalLink_type > InternalLink_sequence;
  typedef InternalLink_sequence::iterator InternalLink_iterator;
  typedef InternalLink_sequence::const_iterator InternalLink_const_iterator;
  typedef ::xsd::cxx::tree::traits< InternalLink_type, char > InternalLink_traits;

  const InternalLink_sequence&
  InternalLink () const;

  InternalLink_sequence&
  InternalLink ();

  void
  InternalLink (const InternalLink_sequence& s);

  // Constructors.
  //
  SystemUnitClassType (const Name_type&);

  SystemUnitClassType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  SystemUnitClassType (const SystemUnitClassType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual SystemUnitClassType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SystemUnitClassType&
  operator= (const SystemUnitClassType& x);

  virtual 
  ~SystemUnitClassType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Attribute_sequence Attribute_;
  ExternalInterface_sequence ExternalInterface_;
  InternalElement_sequence InternalElement_;
  SupportedRoleClass_sequence SupportedRoleClass_;
  InternalLink_sequence InternalLink_;
};

class SystemUnitFamilyType: public ::SystemUnitClassType
{
  public:
  // SystemUnitClass
  //
  typedef ::SystemUnitFamilyType SystemUnitClass_type;
  typedef ::xsd::cxx::tree::sequence< SystemUnitClass_type > SystemUnitClass_sequence;
  typedef SystemUnitClass_sequence::iterator SystemUnitClass_iterator;
  typedef SystemUnitClass_sequence::const_iterator SystemUnitClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< SystemUnitClass_type, char > SystemUnitClass_traits;

  const SystemUnitClass_sequence&
  SystemUnitClass () const;

  SystemUnitClass_sequence&
  SystemUnitClass ();

  void
  SystemUnitClass (const SystemUnitClass_sequence& s);

  // RefBaseClassPath
  //
  typedef ::xml_schema::string RefBaseClassPath_type;
  typedef ::xsd::cxx::tree::optional< RefBaseClassPath_type > RefBaseClassPath_optional;
  typedef ::xsd::cxx::tree::traits< RefBaseClassPath_type, char > RefBaseClassPath_traits;

  const RefBaseClassPath_optional&
  RefBaseClassPath () const;

  RefBaseClassPath_optional&
  RefBaseClassPath ();

  void
  RefBaseClassPath (const RefBaseClassPath_type& x);

  void
  RefBaseClassPath (const RefBaseClassPath_optional& x);

  void
  RefBaseClassPath (::std::auto_ptr< RefBaseClassPath_type > p);

  // Constructors.
  //
  SystemUnitFamilyType (const Name_type&);

  SystemUnitFamilyType (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  SystemUnitFamilyType (const SystemUnitFamilyType& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual SystemUnitFamilyType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SystemUnitFamilyType&
  operator= (const SystemUnitFamilyType& x);

  virtual 
  ~SystemUnitFamilyType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  SystemUnitClass_sequence SystemUnitClass_;
  RefBaseClassPath_optional RefBaseClassPath_;
};

class InternalElementType: public ::SystemUnitClassType
{
  public:
  // RoleRequirements
  //
  typedef ::RoleRequirements RoleRequirements_type;
  typedef ::xsd::cxx::tree::optional< RoleRequirements_type > RoleRequirements_optional;
  typedef ::xsd::cxx::tree::traits< RoleRequirements_type, char > RoleRequirements_traits;

  const RoleRequirements_optional&
  RoleRequirements () const;

  RoleRequirements_optional&
  RoleRequirements ();

  void
  RoleRequirements (const RoleRequirements_type& x);

  void
  RoleRequirements (const RoleRequirements_optional& x);

  void
  RoleRequirements (::std::auto_ptr< RoleRequirements_type > p);

  // MappingObject
  //
  typedef ::MappingType MappingObject_type;
  typedef ::xsd::cxx::tree::optional< MappingObject_type > MappingObject_optional;
  typedef ::xsd::cxx::tree::traits< MappingObject_type, char > MappingObject_traits;

  const MappingObject_optional&
  MappingObject () const;

  MappingObject_optional&
  MappingObject ();

  void
  MappingObject (const MappingObject_type& x);

  void
  MappingObject (const MappingObject_optional& x);

  void
  MappingObject (::std::auto_ptr< MappingObject_type > p);

  // RefBaseSystemUnitPath
  //
  typedef ::xml_schema::string RefBaseSystemUnitPath_type;
  typedef ::xsd::cxx::tree::optional< RefBaseSystemUnitPath_type > RefBaseSystemUnitPath_optional;
  typedef ::xsd::cxx::tree::traits< RefBaseSystemUnitPath_type, char > RefBaseSystemUnitPath_traits;

  const RefBaseSystemUnitPath_optional&
  RefBaseSystemUnitPath () const;

  RefBaseSystemUnitPath_optional&
  RefBaseSystemUnitPath ();

  void
  RefBaseSystemUnitPath (const RefBaseSystemUnitPath_type& x);

  void
  RefBaseSystemUnitPath (const RefBaseSystemUnitPath_optional& x);

  void
  RefBaseSystemUnitPath (::std::auto_ptr< RefBaseSystemUnitPath_type > p);

  // Constructors.
  //
  InternalElementType (const Name_type&);

  InternalElementType (const ::xercesc::DOMElement& e,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  InternalElementType (const InternalElementType& x,
                       ::xml_schema::flags f = 0,
                       ::xml_schema::container* c = 0);

  virtual InternalElementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InternalElementType&
  operator= (const InternalElementType& x);

  virtual 
  ~InternalElementType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  RoleRequirements_optional RoleRequirements_;
  MappingObject_optional MappingObject_;
  RefBaseSystemUnitPath_optional RefBaseSystemUnitPath_;
};

class AttributeType: public ::CAEXObject
{
  public:
  // DefaultValue
  //
  typedef ::xml_schema::type DefaultValue_type;
  typedef ::xsd::cxx::tree::optional< DefaultValue_type > DefaultValue_optional;
  typedef ::xsd::cxx::tree::traits< DefaultValue_type, char > DefaultValue_traits;

  const DefaultValue_optional&
  DefaultValue () const;

  DefaultValue_optional&
  DefaultValue ();

  void
  DefaultValue (const DefaultValue_type& x);

  void
  DefaultValue (const DefaultValue_optional& x);

  void
  DefaultValue (::std::auto_ptr< DefaultValue_type > p);

  // Value
  //
  typedef ::xml_schema::type Value_type;
  typedef ::xsd::cxx::tree::optional< Value_type > Value_optional;
  typedef ::xsd::cxx::tree::traits< Value_type, char > Value_traits;

  const Value_optional&
  Value () const;

  Value_optional&
  Value ();

  void
  Value (const Value_type& x);

  void
  Value (const Value_optional& x);

  void
  Value (::std::auto_ptr< Value_type > p);

  // RefSemantic
  //
  typedef ::RefSemantic RefSemantic_type;
  typedef ::xsd::cxx::tree::sequence< RefSemantic_type > RefSemantic_sequence;
  typedef RefSemantic_sequence::iterator RefSemantic_iterator;
  typedef RefSemantic_sequence::const_iterator RefSemantic_const_iterator;
  typedef ::xsd::cxx::tree::traits< RefSemantic_type, char > RefSemantic_traits;

  const RefSemantic_sequence&
  RefSemantic () const;

  RefSemantic_sequence&
  RefSemantic ();

  void
  RefSemantic (const RefSemantic_sequence& s);

  // Constraint
  //
  typedef ::AttributeValueRequirementType Constraint_type;
  typedef ::xsd::cxx::tree::sequence< Constraint_type > Constraint_sequence;
  typedef Constraint_sequence::iterator Constraint_iterator;
  typedef Constraint_sequence::const_iterator Constraint_const_iterator;
  typedef ::xsd::cxx::tree::traits< Constraint_type, char > Constraint_traits;

  const Constraint_sequence&
  Constraint () const;

  Constraint_sequence&
  Constraint ();

  void
  Constraint (const Constraint_sequence& s);

  // Attribute
  //
  typedef ::AttributeType Attribute_type;
  typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
  typedef Attribute_sequence::iterator Attribute_iterator;
  typedef Attribute_sequence::const_iterator Attribute_const_iterator;
  typedef ::xsd::cxx::tree::traits< Attribute_type, char > Attribute_traits;

  const Attribute_sequence&
  Attribute () const;

  Attribute_sequence&
  Attribute ();

  void
  Attribute (const Attribute_sequence& s);

  // Unit
  //
  typedef ::xml_schema::string Unit_type;
  typedef ::xsd::cxx::tree::optional< Unit_type > Unit_optional;
  typedef ::xsd::cxx::tree::traits< Unit_type, char > Unit_traits;

  const Unit_optional&
  Unit () const;

  Unit_optional&
  Unit ();

  void
  Unit (const Unit_type& x);

  void
  Unit (const Unit_optional& x);

  void
  Unit (::std::auto_ptr< Unit_type > p);

  // AttributeDataType
  //
  typedef ::AttributeDataType AttributeDataType_type;
  typedef ::xsd::cxx::tree::optional< AttributeDataType_type > AttributeDataType_optional;
  typedef ::xsd::cxx::tree::traits< AttributeDataType_type, char > AttributeDataType_traits;

  const AttributeDataType_optional&
  AttributeDataType () const;

  AttributeDataType_optional&
  AttributeDataType ();

  void
  AttributeDataType (const AttributeDataType_type& x);

  void
  AttributeDataType (const AttributeDataType_optional& x);

  void
  AttributeDataType (::std::auto_ptr< AttributeDataType_type > p);

  // Constructors.
  //
  AttributeType (const Name_type&);

  AttributeType (const ::xercesc::DOMElement& e,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  AttributeType (const AttributeType& x,
                 ::xml_schema::flags f = 0,
                 ::xml_schema::container* c = 0);

  virtual AttributeType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AttributeType&
  operator= (const AttributeType& x);

  virtual 
  ~AttributeType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  DefaultValue_optional DefaultValue_;
  Value_optional Value_;
  RefSemantic_sequence RefSemantic_;
  Constraint_sequence Constraint_;
  Attribute_sequence Attribute_;
  Unit_optional Unit_;
  AttributeDataType_optional AttributeDataType_;
};

class AttributeValueRequirementType: public ::CAEXBasicObject
{
  public:
  // OrdinalScaledType
  //
  typedef ::OrdinalScaledType OrdinalScaledType_type;
  typedef ::xsd::cxx::tree::optional< OrdinalScaledType_type > OrdinalScaledType_optional;
  typedef ::xsd::cxx::tree::traits< OrdinalScaledType_type, char > OrdinalScaledType_traits;

  const OrdinalScaledType_optional&
  OrdinalScaledType () const;

  OrdinalScaledType_optional&
  OrdinalScaledType ();

  void
  OrdinalScaledType (const OrdinalScaledType_type& x);

  void
  OrdinalScaledType (const OrdinalScaledType_optional& x);

  void
  OrdinalScaledType (::std::auto_ptr< OrdinalScaledType_type > p);

  // NominalScaledType
  //
  typedef ::NominalScaledType NominalScaledType_type;
  typedef ::xsd::cxx::tree::optional< NominalScaledType_type > NominalScaledType_optional;
  typedef ::xsd::cxx::tree::traits< NominalScaledType_type, char > NominalScaledType_traits;

  const NominalScaledType_optional&
  NominalScaledType () const;

  NominalScaledType_optional&
  NominalScaledType ();

  void
  NominalScaledType (const NominalScaledType_type& x);

  void
  NominalScaledType (const NominalScaledType_optional& x);

  void
  NominalScaledType (::std::auto_ptr< NominalScaledType_type > p);

  // UnknownType
  //
  typedef ::UnknownType UnknownType_type;
  typedef ::xsd::cxx::tree::optional< UnknownType_type > UnknownType_optional;
  typedef ::xsd::cxx::tree::traits< UnknownType_type, char > UnknownType_traits;

  const UnknownType_optional&
  UnknownType () const;

  UnknownType_optional&
  UnknownType ();

  void
  UnknownType (const UnknownType_type& x);

  void
  UnknownType (const UnknownType_optional& x);

  void
  UnknownType (::std::auto_ptr< UnknownType_type > p);

  // Name
  //
  typedef ::xml_schema::string Name_type;
  typedef ::xsd::cxx::tree::traits< Name_type, char > Name_traits;

  const Name_type&
  Name () const;

  Name_type&
  Name ();

  void
  Name (const Name_type& x);

  void
  Name (::std::auto_ptr< Name_type > p);

  // Constructors.
  //
  AttributeValueRequirementType (const Name_type&);

  AttributeValueRequirementType (const ::xercesc::DOMElement& e,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  AttributeValueRequirementType (const AttributeValueRequirementType& x,
                                 ::xml_schema::flags f = 0,
                                 ::xml_schema::container* c = 0);

  virtual AttributeValueRequirementType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AttributeValueRequirementType&
  operator= (const AttributeValueRequirementType& x);

  virtual 
  ~AttributeValueRequirementType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  OrdinalScaledType_optional OrdinalScaledType_;
  NominalScaledType_optional NominalScaledType_;
  UnknownType_optional UnknownType_;
  ::xsd::cxx::tree::one< Name_type > Name_;
};

class MappingType: public ::CAEXBasicObject
{
  public:
  // AttributeNameMapping
  //
  typedef ::AttributeNameMapping AttributeNameMapping_type;
  typedef ::xsd::cxx::tree::sequence< AttributeNameMapping_type > AttributeNameMapping_sequence;
  typedef AttributeNameMapping_sequence::iterator AttributeNameMapping_iterator;
  typedef AttributeNameMapping_sequence::const_iterator AttributeNameMapping_const_iterator;
  typedef ::xsd::cxx::tree::traits< AttributeNameMapping_type, char > AttributeNameMapping_traits;

  const AttributeNameMapping_sequence&
  AttributeNameMapping () const;

  AttributeNameMapping_sequence&
  AttributeNameMapping ();

  void
  AttributeNameMapping (const AttributeNameMapping_sequence& s);

  // InterfaceNameMapping
  //
  typedef ::InterfaceNameMapping InterfaceNameMapping_type;
  typedef ::xsd::cxx::tree::sequence< InterfaceNameMapping_type > InterfaceNameMapping_sequence;
  typedef InterfaceNameMapping_sequence::iterator InterfaceNameMapping_iterator;
  typedef InterfaceNameMapping_sequence::const_iterator InterfaceNameMapping_const_iterator;
  typedef ::xsd::cxx::tree::traits< InterfaceNameMapping_type, char > InterfaceNameMapping_traits;

  const InterfaceNameMapping_sequence&
  InterfaceNameMapping () const;

  InterfaceNameMapping_sequence&
  InterfaceNameMapping ();

  void
  InterfaceNameMapping (const InterfaceNameMapping_sequence& s);

  // Constructors.
  //
  MappingType ();

  MappingType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  MappingType (const MappingType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual MappingType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  MappingType&
  operator= (const MappingType& x);

  virtual 
  ~MappingType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  AttributeNameMapping_sequence AttributeNameMapping_;
  InterfaceNameMapping_sequence InterfaceNameMapping_;
};

class Description: public ::xml_schema::string
{
  public:
  // ChangeMode
  //
  typedef ::ChangeMode ChangeMode_type;
  typedef ::xsd::cxx::tree::traits< ChangeMode_type, char > ChangeMode_traits;

  const ChangeMode_type&
  ChangeMode () const;

  ChangeMode_type&
  ChangeMode ();

  void
  ChangeMode (const ChangeMode_type& x);

  void
  ChangeMode (::std::auto_ptr< ChangeMode_type > p);

  static const ChangeMode_type&
  ChangeMode_default_value ();

  // Constructors.
  //
  Description ();

  Description (const char*);

  Description (const ::std::string&);

  Description (const ::xml_schema::string&);

  Description (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  Description (const Description& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual Description*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Description&
  operator= (const Description& x);

  virtual 
  ~Description ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ChangeMode_type > ChangeMode_;
  static const ChangeMode_type ChangeMode_default_value_;
};

class Version: public ::xml_schema::string
{
  public:
  // ChangeMode
  //
  typedef ::ChangeMode ChangeMode_type;
  typedef ::xsd::cxx::tree::traits< ChangeMode_type, char > ChangeMode_traits;

  const ChangeMode_type&
  ChangeMode () const;

  ChangeMode_type&
  ChangeMode ();

  void
  ChangeMode (const ChangeMode_type& x);

  void
  ChangeMode (::std::auto_ptr< ChangeMode_type > p);

  static const ChangeMode_type&
  ChangeMode_default_value ();

  // Constructors.
  //
  Version ();

  Version (const char*);

  Version (const ::std::string&);

  Version (const ::xml_schema::string&);

  Version (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  Version (const Version& x,
           ::xml_schema::flags f = 0,
           ::xml_schema::container* c = 0);

  virtual Version*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Version&
  operator= (const Version& x);

  virtual 
  ~Version ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ChangeMode_type > ChangeMode_;
  static const ChangeMode_type ChangeMode_default_value_;
};

class Revision: public ::CAEXBasicObject
{
  public:
  // RevisionDate
  //
  typedef ::xml_schema::date_time RevisionDate_type;
  typedef ::xsd::cxx::tree::traits< RevisionDate_type, char > RevisionDate_traits;

  const RevisionDate_type&
  RevisionDate () const;

  RevisionDate_type&
  RevisionDate ();

  void
  RevisionDate (const RevisionDate_type& x);

  void
  RevisionDate (::std::auto_ptr< RevisionDate_type > p);

  // OldVersion
  //
  typedef ::xml_schema::string OldVersion_type;
  typedef ::xsd::cxx::tree::optional< OldVersion_type > OldVersion_optional;
  typedef ::xsd::cxx::tree::traits< OldVersion_type, char > OldVersion_traits;

  const OldVersion_optional&
  OldVersion () const;

  OldVersion_optional&
  OldVersion ();

  void
  OldVersion (const OldVersion_type& x);

  void
  OldVersion (const OldVersion_optional& x);

  void
  OldVersion (::std::auto_ptr< OldVersion_type > p);

  // NewVersion
  //
  typedef ::xml_schema::string NewVersion_type;
  typedef ::xsd::cxx::tree::optional< NewVersion_type > NewVersion_optional;
  typedef ::xsd::cxx::tree::traits< NewVersion_type, char > NewVersion_traits;

  const NewVersion_optional&
  NewVersion () const;

  NewVersion_optional&
  NewVersion ();

  void
  NewVersion (const NewVersion_type& x);

  void
  NewVersion (const NewVersion_optional& x);

  void
  NewVersion (::std::auto_ptr< NewVersion_type > p);

  // AuthorName
  //
  typedef ::xml_schema::string AuthorName_type;
  typedef ::xsd::cxx::tree::traits< AuthorName_type, char > AuthorName_traits;

  const AuthorName_type&
  AuthorName () const;

  AuthorName_type&
  AuthorName ();

  void
  AuthorName (const AuthorName_type& x);

  void
  AuthorName (::std::auto_ptr< AuthorName_type > p);

  // Comment
  //
  typedef ::xml_schema::string Comment_type;
  typedef ::xsd::cxx::tree::optional< Comment_type > Comment_optional;
  typedef ::xsd::cxx::tree::traits< Comment_type, char > Comment_traits;

  const Comment_optional&
  Comment () const;

  Comment_optional&
  Comment ();

  void
  Comment (const Comment_type& x);

  void
  Comment (const Comment_optional& x);

  void
  Comment (::std::auto_ptr< Comment_type > p);

  // Constructors.
  //
  Revision (const RevisionDate_type&,
            const AuthorName_type&);

  Revision (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  Revision (const Revision& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual Revision*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Revision&
  operator= (const Revision& x);

  virtual 
  ~Revision ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< RevisionDate_type > RevisionDate_;
  OldVersion_optional OldVersion_;
  NewVersion_optional NewVersion_;
  ::xsd::cxx::tree::one< AuthorName_type > AuthorName_;
  Comment_optional Comment_;
};

class Copyright: public ::xml_schema::string
{
  public:
  // ChangeMode
  //
  typedef ::ChangeMode ChangeMode_type;
  typedef ::xsd::cxx::tree::traits< ChangeMode_type, char > ChangeMode_traits;

  const ChangeMode_type&
  ChangeMode () const;

  ChangeMode_type&
  ChangeMode ();

  void
  ChangeMode (const ChangeMode_type& x);

  void
  ChangeMode (::std::auto_ptr< ChangeMode_type > p);

  static const ChangeMode_type&
  ChangeMode_default_value ();

  // Constructors.
  //
  Copyright ();

  Copyright (const char*);

  Copyright (const ::std::string&);

  Copyright (const ::xml_schema::string&);

  Copyright (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  Copyright (const Copyright& x,
             ::xml_schema::flags f = 0,
             ::xml_schema::container* c = 0);

  virtual Copyright*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  Copyright&
  operator= (const Copyright& x);

  virtual 
  ~Copyright ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< ChangeMode_type > ChangeMode_;
  static const ChangeMode_type ChangeMode_default_value_;
};

class ExternalInterface: public ::InterfaceClassType
{
  public:
  // Constructors.
  //
  ExternalInterface (const Name_type&);

  ExternalInterface (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ExternalInterface (const ExternalInterface& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ExternalInterface*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~ExternalInterface ();
};

class SupportedRoleClass: public ::CAEXBasicObject
{
  public:
  // MappingObject
  //
  typedef ::MappingType MappingObject_type;
  typedef ::xsd::cxx::tree::optional< MappingObject_type > MappingObject_optional;
  typedef ::xsd::cxx::tree::traits< MappingObject_type, char > MappingObject_traits;

  const MappingObject_optional&
  MappingObject () const;

  MappingObject_optional&
  MappingObject ();

  void
  MappingObject (const MappingObject_type& x);

  void
  MappingObject (const MappingObject_optional& x);

  void
  MappingObject (::std::auto_ptr< MappingObject_type > p);

  // RefRoleClassPath
  //
  typedef ::xml_schema::string RefRoleClassPath_type;
  typedef ::xsd::cxx::tree::traits< RefRoleClassPath_type, char > RefRoleClassPath_traits;

  const RefRoleClassPath_type&
  RefRoleClassPath () const;

  RefRoleClassPath_type&
  RefRoleClassPath ();

  void
  RefRoleClassPath (const RefRoleClassPath_type& x);

  void
  RefRoleClassPath (::std::auto_ptr< RefRoleClassPath_type > p);

  // Constructors.
  //
  SupportedRoleClass (const RefRoleClassPath_type&);

  SupportedRoleClass (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  SupportedRoleClass (const SupportedRoleClass& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual SupportedRoleClass*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SupportedRoleClass&
  operator= (const SupportedRoleClass& x);

  virtual 
  ~SupportedRoleClass ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  MappingObject_optional MappingObject_;
  ::xsd::cxx::tree::one< RefRoleClassPath_type > RefRoleClassPath_;
};

class InternalLink: public ::CAEXObject
{
  public:
  // RefPartnerSideA
  //
  typedef ::xml_schema::string RefPartnerSideA_type;
  typedef ::xsd::cxx::tree::optional< RefPartnerSideA_type > RefPartnerSideA_optional;
  typedef ::xsd::cxx::tree::traits< RefPartnerSideA_type, char > RefPartnerSideA_traits;

  const RefPartnerSideA_optional&
  RefPartnerSideA () const;

  RefPartnerSideA_optional&
  RefPartnerSideA ();

  void
  RefPartnerSideA (const RefPartnerSideA_type& x);

  void
  RefPartnerSideA (const RefPartnerSideA_optional& x);

  void
  RefPartnerSideA (::std::auto_ptr< RefPartnerSideA_type > p);

  // RefPartnerSideB
  //
  typedef ::xml_schema::string RefPartnerSideB_type;
  typedef ::xsd::cxx::tree::optional< RefPartnerSideB_type > RefPartnerSideB_optional;
  typedef ::xsd::cxx::tree::traits< RefPartnerSideB_type, char > RefPartnerSideB_traits;

  const RefPartnerSideB_optional&
  RefPartnerSideB () const;

  RefPartnerSideB_optional&
  RefPartnerSideB ();

  void
  RefPartnerSideB (const RefPartnerSideB_type& x);

  void
  RefPartnerSideB (const RefPartnerSideB_optional& x);

  void
  RefPartnerSideB (::std::auto_ptr< RefPartnerSideB_type > p);

  // Constructors.
  //
  InternalLink (const Name_type&);

  InternalLink (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  InternalLink (const InternalLink& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual InternalLink*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InternalLink&
  operator= (const InternalLink& x);

  virtual 
  ~InternalLink ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  RefPartnerSideA_optional RefPartnerSideA_;
  RefPartnerSideB_optional RefPartnerSideB_;
};

class RoleRequirements: public ::CAEXBasicObject
{
  public:
  // Attribute
  //
  typedef ::AttributeType Attribute_type;
  typedef ::xsd::cxx::tree::sequence< Attribute_type > Attribute_sequence;
  typedef Attribute_sequence::iterator Attribute_iterator;
  typedef Attribute_sequence::const_iterator Attribute_const_iterator;
  typedef ::xsd::cxx::tree::traits< Attribute_type, char > Attribute_traits;

  const Attribute_sequence&
  Attribute () const;

  Attribute_sequence&
  Attribute ();

  void
  Attribute (const Attribute_sequence& s);

  // ExternalInterface
  //
  typedef ::InterfaceClassType ExternalInterface_type;
  typedef ::xsd::cxx::tree::sequence< ExternalInterface_type > ExternalInterface_sequence;
  typedef ExternalInterface_sequence::iterator ExternalInterface_iterator;
  typedef ExternalInterface_sequence::const_iterator ExternalInterface_const_iterator;
  typedef ::xsd::cxx::tree::traits< ExternalInterface_type, char > ExternalInterface_traits;

  const ExternalInterface_sequence&
  ExternalInterface () const;

  ExternalInterface_sequence&
  ExternalInterface ();

  void
  ExternalInterface (const ExternalInterface_sequence& s);

  // RefBaseRoleClassPath
  //
  typedef ::xml_schema::string RefBaseRoleClassPath_type;
  typedef ::xsd::cxx::tree::optional< RefBaseRoleClassPath_type > RefBaseRoleClassPath_optional;
  typedef ::xsd::cxx::tree::traits< RefBaseRoleClassPath_type, char > RefBaseRoleClassPath_traits;

  const RefBaseRoleClassPath_optional&
  RefBaseRoleClassPath () const;

  RefBaseRoleClassPath_optional&
  RefBaseRoleClassPath ();

  void
  RefBaseRoleClassPath (const RefBaseRoleClassPath_type& x);

  void
  RefBaseRoleClassPath (const RefBaseRoleClassPath_optional& x);

  void
  RefBaseRoleClassPath (::std::auto_ptr< RefBaseRoleClassPath_type > p);

  // Constructors.
  //
  RoleRequirements ();

  RoleRequirements (const ::xercesc::DOMElement& e,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  RoleRequirements (const RoleRequirements& x,
                    ::xml_schema::flags f = 0,
                    ::xml_schema::container* c = 0);

  virtual RoleRequirements*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RoleRequirements&
  operator= (const RoleRequirements& x);

  virtual 
  ~RoleRequirements ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Attribute_sequence Attribute_;
  ExternalInterface_sequence ExternalInterface_;
  RefBaseRoleClassPath_optional RefBaseRoleClassPath_;
};

class RefSemantic: public ::CAEXBasicObject
{
  public:
  // CorrespondingAttributePath
  //
  typedef ::xml_schema::string CorrespondingAttributePath_type;
  typedef ::xsd::cxx::tree::traits< CorrespondingAttributePath_type, char > CorrespondingAttributePath_traits;

  const CorrespondingAttributePath_type&
  CorrespondingAttributePath () const;

  CorrespondingAttributePath_type&
  CorrespondingAttributePath ();

  void
  CorrespondingAttributePath (const CorrespondingAttributePath_type& x);

  void
  CorrespondingAttributePath (::std::auto_ptr< CorrespondingAttributePath_type > p);

  // Constructors.
  //
  RefSemantic (const CorrespondingAttributePath_type&);

  RefSemantic (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  RefSemantic (const RefSemantic& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual RefSemantic*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RefSemantic&
  operator= (const RefSemantic& x);

  virtual 
  ~RefSemantic ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< CorrespondingAttributePath_type > CorrespondingAttributePath_;
};

class AttributeDataType: public ::xml_schema::string
{
  public:
  // Constructors.
  //
  AttributeDataType ();

  AttributeDataType (const char*);

  AttributeDataType (const ::std::string&);

  AttributeDataType (const ::xml_schema::string&);

  AttributeDataType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  AttributeDataType (const ::xercesc::DOMAttr& a,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  AttributeDataType (const ::std::string& s,
                     const ::xercesc::DOMElement* e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  AttributeDataType (const AttributeDataType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual AttributeDataType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  virtual 
  ~AttributeDataType ();
};

class OrdinalScaledType: public ::xml_schema::type
{
  public:
  // RequiredMaxValue
  //
  typedef ::xml_schema::type RequiredMaxValue_type;
  typedef ::xsd::cxx::tree::optional< RequiredMaxValue_type > RequiredMaxValue_optional;
  typedef ::xsd::cxx::tree::traits< RequiredMaxValue_type, char > RequiredMaxValue_traits;

  const RequiredMaxValue_optional&
  RequiredMaxValue () const;

  RequiredMaxValue_optional&
  RequiredMaxValue ();

  void
  RequiredMaxValue (const RequiredMaxValue_type& x);

  void
  RequiredMaxValue (const RequiredMaxValue_optional& x);

  void
  RequiredMaxValue (::std::auto_ptr< RequiredMaxValue_type > p);

  // RequiredValue
  //
  typedef ::xml_schema::type RequiredValue_type;
  typedef ::xsd::cxx::tree::optional< RequiredValue_type > RequiredValue_optional;
  typedef ::xsd::cxx::tree::traits< RequiredValue_type, char > RequiredValue_traits;

  const RequiredValue_optional&
  RequiredValue () const;

  RequiredValue_optional&
  RequiredValue ();

  void
  RequiredValue (const RequiredValue_type& x);

  void
  RequiredValue (const RequiredValue_optional& x);

  void
  RequiredValue (::std::auto_ptr< RequiredValue_type > p);

  // RequiredMinValue
  //
  typedef ::xml_schema::type RequiredMinValue_type;
  typedef ::xsd::cxx::tree::optional< RequiredMinValue_type > RequiredMinValue_optional;
  typedef ::xsd::cxx::tree::traits< RequiredMinValue_type, char > RequiredMinValue_traits;

  const RequiredMinValue_optional&
  RequiredMinValue () const;

  RequiredMinValue_optional&
  RequiredMinValue ();

  void
  RequiredMinValue (const RequiredMinValue_type& x);

  void
  RequiredMinValue (const RequiredMinValue_optional& x);

  void
  RequiredMinValue (::std::auto_ptr< RequiredMinValue_type > p);

  // Constructors.
  //
  OrdinalScaledType ();

  OrdinalScaledType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  OrdinalScaledType (const OrdinalScaledType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual OrdinalScaledType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  OrdinalScaledType&
  operator= (const OrdinalScaledType& x);

  virtual 
  ~OrdinalScaledType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  RequiredMaxValue_optional RequiredMaxValue_;
  RequiredValue_optional RequiredValue_;
  RequiredMinValue_optional RequiredMinValue_;
};

class NominalScaledType: public ::xml_schema::type
{
  public:
  // RequiredValue
  //
  typedef ::xml_schema::type RequiredValue_type;
  typedef ::xsd::cxx::tree::sequence< RequiredValue_type > RequiredValue_sequence;
  typedef RequiredValue_sequence::iterator RequiredValue_iterator;
  typedef RequiredValue_sequence::const_iterator RequiredValue_const_iterator;
  typedef ::xsd::cxx::tree::traits< RequiredValue_type, char > RequiredValue_traits;

  const RequiredValue_sequence&
  RequiredValue () const;

  RequiredValue_sequence&
  RequiredValue ();

  void
  RequiredValue (const RequiredValue_sequence& s);

  // Constructors.
  //
  NominalScaledType ();

  NominalScaledType (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  NominalScaledType (const NominalScaledType& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual NominalScaledType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  NominalScaledType&
  operator= (const NominalScaledType& x);

  virtual 
  ~NominalScaledType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  RequiredValue_sequence RequiredValue_;
};

class UnknownType: public ::xml_schema::type
{
  public:
  // Requirements
  //
  typedef ::xml_schema::string Requirements_type;
  typedef ::xsd::cxx::tree::optional< Requirements_type > Requirements_optional;
  typedef ::xsd::cxx::tree::traits< Requirements_type, char > Requirements_traits;

  const Requirements_optional&
  Requirements () const;

  Requirements_optional&
  Requirements ();

  void
  Requirements (const Requirements_type& x);

  void
  Requirements (const Requirements_optional& x);

  void
  Requirements (::std::auto_ptr< Requirements_type > p);

  // Constructors.
  //
  UnknownType ();

  UnknownType (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  UnknownType (const UnknownType& x,
               ::xml_schema::flags f = 0,
               ::xml_schema::container* c = 0);

  virtual UnknownType*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  UnknownType&
  operator= (const UnknownType& x);

  virtual 
  ~UnknownType ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  Requirements_optional Requirements_;
};

class AttributeNameMapping: public ::CAEXBasicObject
{
  public:
  // SystemUnitAttributeName
  //
  typedef ::xml_schema::string SystemUnitAttributeName_type;
  typedef ::xsd::cxx::tree::traits< SystemUnitAttributeName_type, char > SystemUnitAttributeName_traits;

  const SystemUnitAttributeName_type&
  SystemUnitAttributeName () const;

  SystemUnitAttributeName_type&
  SystemUnitAttributeName ();

  void
  SystemUnitAttributeName (const SystemUnitAttributeName_type& x);

  void
  SystemUnitAttributeName (::std::auto_ptr< SystemUnitAttributeName_type > p);

  // RoleAttributeName
  //
  typedef ::xml_schema::string RoleAttributeName_type;
  typedef ::xsd::cxx::tree::traits< RoleAttributeName_type, char > RoleAttributeName_traits;

  const RoleAttributeName_type&
  RoleAttributeName () const;

  RoleAttributeName_type&
  RoleAttributeName ();

  void
  RoleAttributeName (const RoleAttributeName_type& x);

  void
  RoleAttributeName (::std::auto_ptr< RoleAttributeName_type > p);

  // Constructors.
  //
  AttributeNameMapping (const SystemUnitAttributeName_type&,
                        const RoleAttributeName_type&);

  AttributeNameMapping (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  AttributeNameMapping (const AttributeNameMapping& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual AttributeNameMapping*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  AttributeNameMapping&
  operator= (const AttributeNameMapping& x);

  virtual 
  ~AttributeNameMapping ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SystemUnitAttributeName_type > SystemUnitAttributeName_;
  ::xsd::cxx::tree::one< RoleAttributeName_type > RoleAttributeName_;
};

class InterfaceNameMapping: public ::CAEXBasicObject
{
  public:
  // SystemUnitInterfaceName
  //
  typedef ::xml_schema::string SystemUnitInterfaceName_type;
  typedef ::xsd::cxx::tree::traits< SystemUnitInterfaceName_type, char > SystemUnitInterfaceName_traits;

  const SystemUnitInterfaceName_type&
  SystemUnitInterfaceName () const;

  SystemUnitInterfaceName_type&
  SystemUnitInterfaceName ();

  void
  SystemUnitInterfaceName (const SystemUnitInterfaceName_type& x);

  void
  SystemUnitInterfaceName (::std::auto_ptr< SystemUnitInterfaceName_type > p);

  // RoleInterfaceName
  //
  typedef ::xml_schema::string RoleInterfaceName_type;
  typedef ::xsd::cxx::tree::traits< RoleInterfaceName_type, char > RoleInterfaceName_traits;

  const RoleInterfaceName_type&
  RoleInterfaceName () const;

  RoleInterfaceName_type&
  RoleInterfaceName ();

  void
  RoleInterfaceName (const RoleInterfaceName_type& x);

  void
  RoleInterfaceName (::std::auto_ptr< RoleInterfaceName_type > p);

  // Constructors.
  //
  InterfaceNameMapping (const SystemUnitInterfaceName_type&,
                        const RoleInterfaceName_type&);

  InterfaceNameMapping (const ::xercesc::DOMElement& e,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  InterfaceNameMapping (const InterfaceNameMapping& x,
                        ::xml_schema::flags f = 0,
                        ::xml_schema::container* c = 0);

  virtual InterfaceNameMapping*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InterfaceNameMapping&
  operator= (const InterfaceNameMapping& x);

  virtual 
  ~InterfaceNameMapping ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< SystemUnitInterfaceName_type > SystemUnitInterfaceName_;
  ::xsd::cxx::tree::one< RoleInterfaceName_type > RoleInterfaceName_;
};

class CAEXFile: public ::CAEXBasicObject
{
  public:
  // ExternalReference
  //
  typedef ::ExternalReference ExternalReference_type;
  typedef ::xsd::cxx::tree::sequence< ExternalReference_type > ExternalReference_sequence;
  typedef ExternalReference_sequence::iterator ExternalReference_iterator;
  typedef ExternalReference_sequence::const_iterator ExternalReference_const_iterator;
  typedef ::xsd::cxx::tree::traits< ExternalReference_type, char > ExternalReference_traits;

  const ExternalReference_sequence&
  ExternalReference () const;

  ExternalReference_sequence&
  ExternalReference ();

  void
  ExternalReference (const ExternalReference_sequence& s);

  // InstanceHierarchy
  //
  typedef ::InstanceHierarchy InstanceHierarchy_type;
  typedef ::xsd::cxx::tree::sequence< InstanceHierarchy_type > InstanceHierarchy_sequence;
  typedef InstanceHierarchy_sequence::iterator InstanceHierarchy_iterator;
  typedef InstanceHierarchy_sequence::const_iterator InstanceHierarchy_const_iterator;
  typedef ::xsd::cxx::tree::traits< InstanceHierarchy_type, char > InstanceHierarchy_traits;

  const InstanceHierarchy_sequence&
  InstanceHierarchy () const;

  InstanceHierarchy_sequence&
  InstanceHierarchy ();

  void
  InstanceHierarchy (const InstanceHierarchy_sequence& s);

  // InterfaceClassLib
  //
  typedef ::InterfaceClassLib InterfaceClassLib_type;
  typedef ::xsd::cxx::tree::sequence< InterfaceClassLib_type > InterfaceClassLib_sequence;
  typedef InterfaceClassLib_sequence::iterator InterfaceClassLib_iterator;
  typedef InterfaceClassLib_sequence::const_iterator InterfaceClassLib_const_iterator;
  typedef ::xsd::cxx::tree::traits< InterfaceClassLib_type, char > InterfaceClassLib_traits;

  const InterfaceClassLib_sequence&
  InterfaceClassLib () const;

  InterfaceClassLib_sequence&
  InterfaceClassLib ();

  void
  InterfaceClassLib (const InterfaceClassLib_sequence& s);

  // RoleClassLib
  //
  typedef ::RoleClassLib RoleClassLib_type;
  typedef ::xsd::cxx::tree::sequence< RoleClassLib_type > RoleClassLib_sequence;
  typedef RoleClassLib_sequence::iterator RoleClassLib_iterator;
  typedef RoleClassLib_sequence::const_iterator RoleClassLib_const_iterator;
  typedef ::xsd::cxx::tree::traits< RoleClassLib_type, char > RoleClassLib_traits;

  const RoleClassLib_sequence&
  RoleClassLib () const;

  RoleClassLib_sequence&
  RoleClassLib ();

  void
  RoleClassLib (const RoleClassLib_sequence& s);

  // SystemUnitClassLib
  //
  typedef ::SystemUnitClassLib SystemUnitClassLib_type;
  typedef ::xsd::cxx::tree::sequence< SystemUnitClassLib_type > SystemUnitClassLib_sequence;
  typedef SystemUnitClassLib_sequence::iterator SystemUnitClassLib_iterator;
  typedef SystemUnitClassLib_sequence::const_iterator SystemUnitClassLib_const_iterator;
  typedef ::xsd::cxx::tree::traits< SystemUnitClassLib_type, char > SystemUnitClassLib_traits;

  const SystemUnitClassLib_sequence&
  SystemUnitClassLib () const;

  SystemUnitClassLib_sequence&
  SystemUnitClassLib ();

  void
  SystemUnitClassLib (const SystemUnitClassLib_sequence& s);

  // FileName
  //
  typedef ::xml_schema::string FileName_type;
  typedef ::xsd::cxx::tree::traits< FileName_type, char > FileName_traits;

  const FileName_type&
  FileName () const;

  FileName_type&
  FileName ();

  void
  FileName (const FileName_type& x);

  void
  FileName (::std::auto_ptr< FileName_type > p);

  // SchemaVersion
  //
  typedef ::xml_schema::string SchemaVersion_type;
  typedef ::xsd::cxx::tree::traits< SchemaVersion_type, char > SchemaVersion_traits;

  const SchemaVersion_type&
  SchemaVersion () const;

  static const SchemaVersion_type&
  SchemaVersion_default_value ();

  // Constructors.
  //
  CAEXFile (const FileName_type&);

  CAEXFile (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  CAEXFile (const CAEXFile& x,
            ::xml_schema::flags f = 0,
            ::xml_schema::container* c = 0);

  virtual CAEXFile*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  CAEXFile&
  operator= (const CAEXFile& x);

  virtual 
  ~CAEXFile ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ExternalReference_sequence ExternalReference_;
  InstanceHierarchy_sequence InstanceHierarchy_;
  InterfaceClassLib_sequence InterfaceClassLib_;
  RoleClassLib_sequence RoleClassLib_;
  SystemUnitClassLib_sequence SystemUnitClassLib_;
  ::xsd::cxx::tree::one< FileName_type > FileName_;
  ::xsd::cxx::tree::one< SchemaVersion_type > SchemaVersion_;
  static const SchemaVersion_type SchemaVersion_default_value_;
};

class ExternalReference: public ::CAEXBasicObject
{
  public:
  // Path
  //
  typedef ::xml_schema::string Path_type;
  typedef ::xsd::cxx::tree::traits< Path_type, char > Path_traits;

  const Path_type&
  Path () const;

  Path_type&
  Path ();

  void
  Path (const Path_type& x);

  void
  Path (::std::auto_ptr< Path_type > p);

  // Alias
  //
  typedef ::xml_schema::string Alias_type;
  typedef ::xsd::cxx::tree::traits< Alias_type, char > Alias_traits;

  const Alias_type&
  Alias () const;

  Alias_type&
  Alias ();

  void
  Alias (const Alias_type& x);

  void
  Alias (::std::auto_ptr< Alias_type > p);

  // Constructors.
  //
  ExternalReference (const Path_type&,
                     const Alias_type&);

  ExternalReference (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  ExternalReference (const ExternalReference& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual ExternalReference*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  ExternalReference&
  operator= (const ExternalReference& x);

  virtual 
  ~ExternalReference ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  ::xsd::cxx::tree::one< Path_type > Path_;
  ::xsd::cxx::tree::one< Alias_type > Alias_;
};

class InstanceHierarchy: public ::CAEXObject
{
  public:
  // InternalElement
  //
  typedef ::InternalElementType InternalElement_type;
  typedef ::xsd::cxx::tree::sequence< InternalElement_type > InternalElement_sequence;
  typedef InternalElement_sequence::iterator InternalElement_iterator;
  typedef InternalElement_sequence::const_iterator InternalElement_const_iterator;
  typedef ::xsd::cxx::tree::traits< InternalElement_type, char > InternalElement_traits;

  const InternalElement_sequence&
  InternalElement () const;

  InternalElement_sequence&
  InternalElement ();

  void
  InternalElement (const InternalElement_sequence& s);

  // Constructors.
  //
  InstanceHierarchy (const Name_type&);

  InstanceHierarchy (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  InstanceHierarchy (const InstanceHierarchy& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual InstanceHierarchy*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InstanceHierarchy&
  operator= (const InstanceHierarchy& x);

  virtual 
  ~InstanceHierarchy ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  InternalElement_sequence InternalElement_;
};

class InterfaceClassLib: public ::CAEXObject
{
  public:
  // InterfaceClass
  //
  typedef ::InterfaceFamilyType InterfaceClass_type;
  typedef ::xsd::cxx::tree::sequence< InterfaceClass_type > InterfaceClass_sequence;
  typedef InterfaceClass_sequence::iterator InterfaceClass_iterator;
  typedef InterfaceClass_sequence::const_iterator InterfaceClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< InterfaceClass_type, char > InterfaceClass_traits;

  const InterfaceClass_sequence&
  InterfaceClass () const;

  InterfaceClass_sequence&
  InterfaceClass ();

  void
  InterfaceClass (const InterfaceClass_sequence& s);

  // Constructors.
  //
  InterfaceClassLib (const Name_type&);

  InterfaceClassLib (const ::xercesc::DOMElement& e,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  InterfaceClassLib (const InterfaceClassLib& x,
                     ::xml_schema::flags f = 0,
                     ::xml_schema::container* c = 0);

  virtual InterfaceClassLib*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  InterfaceClassLib&
  operator= (const InterfaceClassLib& x);

  virtual 
  ~InterfaceClassLib ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  InterfaceClass_sequence InterfaceClass_;
};

class RoleClassLib: public ::CAEXObject
{
  public:
  // RoleClass
  //
  typedef ::RoleFamilyType RoleClass_type;
  typedef ::xsd::cxx::tree::sequence< RoleClass_type > RoleClass_sequence;
  typedef RoleClass_sequence::iterator RoleClass_iterator;
  typedef RoleClass_sequence::const_iterator RoleClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< RoleClass_type, char > RoleClass_traits;

  const RoleClass_sequence&
  RoleClass () const;

  RoleClass_sequence&
  RoleClass ();

  void
  RoleClass (const RoleClass_sequence& s);

  // Constructors.
  //
  RoleClassLib (const Name_type&);

  RoleClassLib (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  RoleClassLib (const RoleClassLib& x,
                ::xml_schema::flags f = 0,
                ::xml_schema::container* c = 0);

  virtual RoleClassLib*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  RoleClassLib&
  operator= (const RoleClassLib& x);

  virtual 
  ~RoleClassLib ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  RoleClass_sequence RoleClass_;
};

class SystemUnitClassLib: public ::CAEXObject
{
  public:
  // SystemUnitClass
  //
  typedef ::SystemUnitFamilyType SystemUnitClass_type;
  typedef ::xsd::cxx::tree::sequence< SystemUnitClass_type > SystemUnitClass_sequence;
  typedef SystemUnitClass_sequence::iterator SystemUnitClass_iterator;
  typedef SystemUnitClass_sequence::const_iterator SystemUnitClass_const_iterator;
  typedef ::xsd::cxx::tree::traits< SystemUnitClass_type, char > SystemUnitClass_traits;

  const SystemUnitClass_sequence&
  SystemUnitClass () const;

  SystemUnitClass_sequence&
  SystemUnitClass ();

  void
  SystemUnitClass (const SystemUnitClass_sequence& s);

  // Constructors.
  //
  SystemUnitClassLib (const Name_type&);

  SystemUnitClassLib (const ::xercesc::DOMElement& e,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  SystemUnitClassLib (const SystemUnitClassLib& x,
                      ::xml_schema::flags f = 0,
                      ::xml_schema::container* c = 0);

  virtual SystemUnitClassLib*
  _clone (::xml_schema::flags f = 0,
          ::xml_schema::container* c = 0) const;

  SystemUnitClassLib&
  operator= (const SystemUnitClassLib& x);

  virtual 
  ~SystemUnitClassLib ();

  // Implementation.
  //
  protected:
  void
  parse (::xsd::cxx::xml::dom::parser< char >&,
         ::xml_schema::flags);

  protected:
  SystemUnitClass_sequence SystemUnitClass_;
};

#include <iosfwd>

#include <xercesc/sax/InputSource.hpp>
#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>

// Parse a URI or a local file.
//

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::std::string& uri,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::std::string& uri,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::std::string& uri,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse std::istream.
//

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           const ::std::string& id,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::std::istream& is,
           const ::std::string& id,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::InputSource.
//

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xercesc::InputSource& is,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xercesc::InputSource& is,
           ::xml_schema::error_handler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xercesc::InputSource& is,
           ::xercesc::DOMErrorHandler& eh,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

// Parse xercesc::DOMDocument.
//

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (const ::xercesc::DOMDocument& d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

::std::auto_ptr< ::CAEXFile >
CAEXFile_ (::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument > d,
           ::xml_schema::flags f = 0,
           const ::xml_schema::properties& p = ::xml_schema::properties ());

#include <iosfwd>

#include <xercesc/dom/DOMDocument.hpp>
#include <xercesc/dom/DOMErrorHandler.hpp>
#include <xercesc/framework/XMLFormatter.hpp>

#include <xsd/cxx/xml/dom/auto-ptr.hxx>

void
operator<< (::xercesc::DOMElement&, const ChangeMode&);

void
operator<< (::xercesc::DOMAttr&, const ChangeMode&);

void
operator<< (::xml_schema::list_stream&,
            const ChangeMode&);

void
operator<< (::xercesc::DOMElement&, const CAEXBasicObject&);

void
operator<< (::xercesc::DOMElement&, const CAEXObject&);

void
operator<< (::xercesc::DOMElement&, const InterfaceClassType&);

void
operator<< (::xercesc::DOMElement&, const InterfaceFamilyType&);

void
operator<< (::xercesc::DOMElement&, const RoleClassType&);

void
operator<< (::xercesc::DOMElement&, const RoleFamilyType&);

void
operator<< (::xercesc::DOMElement&, const SystemUnitClassType&);

void
operator<< (::xercesc::DOMElement&, const SystemUnitFamilyType&);

void
operator<< (::xercesc::DOMElement&, const InternalElementType&);

void
operator<< (::xercesc::DOMElement&, const AttributeType&);

void
operator<< (::xercesc::DOMElement&, const AttributeValueRequirementType&);

void
operator<< (::xercesc::DOMElement&, const MappingType&);

// Serialize to std::ostream.
//

void
CAEXFile_ (::std::ostream& os,
           const ::CAEXFile& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
CAEXFile_ (::std::ostream& os,
           const ::CAEXFile& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
CAEXFile_ (::std::ostream& os,
           const ::CAEXFile& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to xercesc::XMLFormatTarget.
//

void
CAEXFile_ (::xercesc::XMLFormatTarget& ft,
           const ::CAEXFile& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
CAEXFile_ (::xercesc::XMLFormatTarget& ft,
           const ::CAEXFile& x, 
           ::xml_schema::error_handler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

void
CAEXFile_ (::xercesc::XMLFormatTarget& ft,
           const ::CAEXFile& x, 
           ::xercesc::DOMErrorHandler& eh,
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           const ::std::string& e = "UTF-8",
           ::xml_schema::flags f = 0);

// Serialize to an existing xercesc::DOMDocument.
//

void
CAEXFile_ (::xercesc::DOMDocument& d,
           const ::CAEXFile& x,
           ::xml_schema::flags f = 0);

// Serialize to a new xercesc::DOMDocument.
//

::xml_schema::dom::auto_ptr< ::xercesc::DOMDocument >
CAEXFile_ (const ::CAEXFile& x, 
           const ::xml_schema::namespace_infomap& m = ::xml_schema::namespace_infomap (),
           ::xml_schema::flags f = 0);

void
operator<< (::xercesc::DOMElement&, const Description&);

void
operator<< (::xercesc::DOMElement&, const Version&);

void
operator<< (::xercesc::DOMElement&, const Revision&);

void
operator<< (::xercesc::DOMElement&, const Copyright&);

void
operator<< (::xercesc::DOMElement&, const ExternalInterface&);

void
operator<< (::xercesc::DOMElement&, const SupportedRoleClass&);

void
operator<< (::xercesc::DOMElement&, const InternalLink&);

void
operator<< (::xercesc::DOMElement&, const RoleRequirements&);

void
operator<< (::xercesc::DOMElement&, const RefSemantic&);

void
operator<< (::xercesc::DOMElement&, const AttributeDataType&);

void
operator<< (::xercesc::DOMAttr&, const AttributeDataType&);

void
operator<< (::xml_schema::list_stream&,
            const AttributeDataType&);

void
operator<< (::xercesc::DOMElement&, const OrdinalScaledType&);

void
operator<< (::xercesc::DOMElement&, const NominalScaledType&);

void
operator<< (::xercesc::DOMElement&, const UnknownType&);

void
operator<< (::xercesc::DOMElement&, const AttributeNameMapping&);

void
operator<< (::xercesc::DOMElement&, const InterfaceNameMapping&);

void
operator<< (::xercesc::DOMElement&, const CAEXFile&);

void
operator<< (::xercesc::DOMElement&, const ExternalReference&);

void
operator<< (::xercesc::DOMElement&, const InstanceHierarchy&);

void
operator<< (::xercesc::DOMElement&, const InterfaceClassLib&);

void
operator<< (::xercesc::DOMElement&, const RoleClassLib&);

void
operator<< (::xercesc::DOMElement&, const SystemUnitClassLib&);

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

#endif // CAEX_CLASSMODEL_V2_15_HXX
